import type { SearchArgs } from './clients/search';
import type { Loaders } from './loaders';
import type { Clients } from './clients';
import type { Channel } from './utils/channel';
export interface Options {
    platform: 'vtex';
    account: string;
    environment: 'vtexcommercestable' | 'vtexcommercebeta';
    channel: string;
    locale: string;
    hideUnavailableItems: boolean;
    flags?: FeatureFlags;
}
interface FeatureFlags {
    enableOrderFormSync?: boolean;
}
export interface Context {
    clients: Clients;
    loaders: Loaders;
    /**
     * @description Storage updated at each request.
     *
     * Use this datastructure to store and share small values in the context.
     * Use it with caution since dependecy injection leads to a more complex code
     * */
    storage: {
        channel: Required<Channel>;
        locale: string;
        flags: FeatureFlags;
        searchArgs?: Omit<SearchArgs, 'type'>;
    };
    headers: Record<string, string>;
}
export declare type Resolver<R = unknown, A = unknown, Return = any> = (root: R, args: A, ctx: Context, info: any) => Return;
export declare const getContextFactory: (options: Options) => (ctx: any) => Context;
export declare const getResolvers: (_: Options) => {
    StoreCollection: Record<string, Resolver<import("./clients/commerce/types/Brand").Brand | import("./clients/commerce/types/Portal").CollectionPageType | (import("./clients/commerce/types/CategoryTree").CategoryTree & {
        level: number;
    }), unknown, any>>;
    StoreAggregateOffer: Record<string, Resolver<import("./utils/enhanceCommercialOffer").EnhancedCommercialOffer<import("./clients/search/types/ProductSearchResult").Seller, import("./clients/search/types/ProductSearchResult").Item & {
        isVariantOf: import("./clients/search/types/ProductSearchResult").Product;
    } & {
        attachmentsValues?: import("./clients/commerce/types/OrderForm").Attachment[] | undefined;
    }>[], unknown, any>> & {
        offers: Resolver<import("./utils/enhanceCommercialOffer").EnhancedCommercialOffer<import("./clients/search/types/ProductSearchResult").Seller, import("./clients/search/types/ProductSearchResult").Item & {
            isVariantOf: import("./clients/search/types/ProductSearchResult").Product;
        } & {
            attachmentsValues?: import("./clients/commerce/types/OrderForm").Attachment[] | undefined;
        }>[], any, import("./utils/enhanceCommercialOffer").EnhancedCommercialOffer<import("./clients/search/types/ProductSearchResult").Seller, import("./clients/search/types/ProductSearchResult").Item & {
            isVariantOf: import("./clients/search/types/ProductSearchResult").Product;
        } & {
            attachmentsValues?: import("./clients/commerce/types/OrderForm").Attachment[] | undefined;
        }>[]>;
    };
    StoreProduct: Record<string, Resolver<import("./clients/search/types/ProductSearchResult").Item & {
        isVariantOf: import("./clients/search/types/ProductSearchResult").Product;
    } & {
        attachmentsValues?: import("./clients/commerce/types/OrderForm").Attachment[] | undefined;
    }, unknown, any>> & {
        offers: Resolver<import("./clients/search/types/ProductSearchResult").Item & {
            isVariantOf: import("./clients/search/types/ProductSearchResult").Product;
        } & {
            attachmentsValues?: import("./clients/commerce/types/OrderForm").Attachment[] | undefined;
        }, any, import("./utils/enhanceCommercialOffer").EnhancedCommercialOffer<import("./clients/search/types/ProductSearchResult").Seller, import("./clients/search/types/ProductSearchResult").Item & {
            isVariantOf: import("./clients/search/types/ProductSearchResult").Product;
        } & {
            attachmentsValues?: import("./clients/commerce/types/OrderForm").Attachment[] | undefined;
        }>[]>;
        isVariantOf: Resolver<import("./clients/search/types/ProductSearchResult").Item & {
            isVariantOf: import("./clients/search/types/ProductSearchResult").Product;
        } & {
            attachmentsValues?: import("./clients/commerce/types/OrderForm").Attachment[] | undefined;
        }, any, import("./clients/search/types/ProductSearchResult").Item & {
            isVariantOf: import("./clients/search/types/ProductSearchResult").Product;
        } & {
            attachmentsValues?: import("./clients/commerce/types/OrderForm").Attachment[] | undefined;
        }>;
    };
    StoreSeo: Record<string, Resolver<{
        title?: string | undefined;
        description?: string | undefined;
        canonical?: string | undefined;
    }, unknown, any>>;
    StoreFacet: Record<string, Resolver<import("./clients/search/types/FacetSearchResult").Facet<import("./clients/search/types/FacetSearchResult").FacetValueBoolean | import("./clients/search/types/FacetSearchResult").FacetValueRange>, unknown, any>>;
    StoreFacetBoolean: Record<string, Resolver<import("./clients/search/types/FacetSearchResult").Facet<import("./clients/search/types/FacetSearchResult").FacetValueBoolean>, unknown, any>>;
    StoreFacetRange: Record<string, Resolver<import("./clients/search/types/FacetSearchResult").Facet<import("./clients/search/types/FacetSearchResult").FacetValueRange>, unknown, any>>;
    StoreFacetValueBoolean: Record<string, Resolver<import("./clients/search/types/FacetSearchResult").FacetValueBoolean, unknown, any>>;
    StoreOffer: Record<string, Resolver<import("./utils/enhanceCommercialOffer").EnhancedCommercialOffer<import("./clients/search/types/ProductSearchResult").Seller, import("./clients/search/types/ProductSearchResult").Item & {
        isVariantOf: import("./clients/search/types/ProductSearchResult").Product;
    } & {
        attachmentsValues?: import("./clients/commerce/types/OrderForm").Attachment[] | undefined;
    }> | (import("./clients/commerce/types/OrderForm").OrderFormItem & {
        product: import("./utils/enhanceSku").EnhancedSku;
    }), unknown, any>>;
    StoreAggregateRating: Record<string, Resolver<unknown, unknown, any>>;
    StoreReview: Record<string, Resolver<unknown, unknown, any>>;
    StoreProductGroup: Record<string, Resolver<import("./clients/search/types/ProductSearchResult").Item & {
        isVariantOf: import("./clients/search/types/ProductSearchResult").Product;
    } & {
        attachmentsValues?: import("./clients/commerce/types/OrderForm").Attachment[] | undefined;
    }, unknown, any>>;
    StoreSearchResult: Record<string, Resolver<Pick<SearchArgs, "hideUnavailableItems" | "query" | "page" | "count" | "sort" | "selectedFacets" | "fuzzy">, unknown, any>>;
    StorePropertyValue: Record<string, Resolver<import("../..").IStorePropertyValue, unknown, any>>;
    ObjectOrString: import("graphql").GraphQLScalarType;
    Query: {
        product: (_: unknown, { locator }: import("../..").QueryProductArgs, ctx: Context) => Promise<import("./utils/enhanceSku").EnhancedSku>;
        collection: (_: unknown, { slug }: import("../..").QueryCollectionArgs, ctx: Context) => Promise<import("./clients/commerce/types/Portal").CollectionPageType>;
        search: (_: unknown, { first, after: maybeAfter, sort, term, selectedFacets }: import("../..").QuerySearchArgs, ctx: Context) => Promise<{
            page: number;
            count: number;
            query: string | null | undefined;
            sort: import("./clients/search").Sort;
            selectedFacets: {
                key: string;
                value: string;
            }[];
        }>;
        allProducts: (_: unknown, { first, after: maybeAfter }: import("../..").QueryAllProductsArgs, ctx: Context) => Promise<{
            pageInfo: {
                hasNextPage: boolean;
                hasPreviousPage: boolean;
                startCursor: string;
                endCursor: string;
                totalCount: number;
            };
            edges: {
                node: import("./utils/enhanceSku").EnhancedSku;
                cursor: string;
            }[];
        }>;
        allCollections: (_: unknown, { first, after: maybeAfter }: import("../..").QueryAllCollectionsArgs, ctx: Context) => Promise<{
            pageInfo: {
                hasNextPage: boolean;
                hasPreviousPage: boolean;
                startCursor: string;
                endCursor: string;
                totalCount: number;
            };
            edges: {
                node: {
                    type: string;
                    id: number;
                    name: string;
                    isActive: boolean;
                    title: string;
                    metaTagDescription: string;
                    imageURL: string | null;
                } | (import("./clients/commerce/types/CategoryTree").CategoryTree & {
                    level: number;
                });
                cursor: string;
            }[];
        }>;
    };
    Mutation: {
        validateCart: (_: unknown, { cart: { order } }: {
            cart: import("../..").IStoreCart;
        }, ctx: Context) => Promise<{
            order: {
                orderNumber: string;
                acceptedOffer: Promise<{
                    product: import("./utils/enhanceSku").EnhancedSku;
                    id: string;
                    name: string;
                    detailUrl: string;
                    imageUrl: string;
                    skuName: string;
                    quantity: number;
                    uniqueId: string;
                    productId: string;
                    refId: string;
                    ean: string;
                    priceValidUntil: string;
                    price: number;
                    tax: number;
                    listPrice: number;
                    sellingPrice: number;
                    rewardValue: number;
                    isGift: boolean;
                    parentItemIndex: number | null;
                    parentAssemblyBinding: string | null;
                    productCategoryIds: string;
                    priceTags: string[];
                    manualPrice: number;
                    measurementUnit: string;
                    additionalInfo: {
                        brandName: string;
                        brandId: string;
                        offeringInfo: any;
                        offeringType: any;
                        offeringTypeId: any;
                    };
                    productCategories: Record<string, string>;
                    productRefId: string;
                    seller: string;
                    sellerChain: string[];
                    availability: string;
                    unitMultiplier: number;
                    skuSpecifications: import("./clients/commerce/types/OrderForm").SKUSpecification[];
                    priceDefinition: {
                        calculatedSellingPrice: number;
                        sellingPrices: import("./clients/commerce/types/OrderForm").SellingPrice[];
                        total: number;
                    };
                    attachments: import("./clients/commerce/types/OrderForm").Attachment[];
                }>[];
            };
            messages: {
                text: any;
                status: any;
            }[];
        } | null>;
        validateSession: (_: any, { session: oldSession, search }: import("../..").MutationValidateSessionArgs, { clients }: Context) => Promise<import("../..").StoreSession | null>;
    };
};
export {};
