import { makeExecutableSchema } from '@graphql-tools/schema';
import fetch from 'isomorphic-unfetch';
import DataLoader from 'dataloader';
import pLimit from 'p-limit';
import deepEquals from 'fast-deep-equal';
import crypto from 'crypto';
import { GraphQLScalarType, print } from 'graphql';
import { Kind } from 'graphql/language';

const fetchAPI = async (info, init) => {
  const response = await fetch(info, init);

  if (response.ok) {
    return response.status !== 204 ? response.json() : undefined;
  }

  console.error(info, init, response);
  const text = await response.text();
  throw new Error(text);
};

const BASE_INIT = {
  method: 'POST',
  headers: {
    'content-type': 'application/json'
  }
};
const VtexCommerce = ({
  account,
  environment
}, ctx) => {
  const base = `https://${account}.${environment}.com.br`;
  return {
    catalog: {
      salesChannel: sc => fetchAPI(`${base}/api/catalog_system/pub/saleschannel/${sc}`),
      brand: {
        list: () => fetchAPI(`${base}/api/catalog_system/pub/brand/list`)
      },
      category: {
        tree: (depth = 3) => fetchAPI(`${base}/api/catalog_system/pub/category/tree/${depth}`)
      },
      portal: {
        pagetype: slug => fetchAPI(`${base}/api/catalog_system/pub/portal/pagetype/${slug}`)
      },
      products: {
        crossselling: ({
          type,
          productId,
          groupByProduct = true
        }) => {
          const params = new URLSearchParams({
            sc: ctx.storage.channel.salesChannel,
            groupByProduct: groupByProduct.toString()
          });
          return fetchAPI(`${base}/api/catalog_system/pub/products/crossselling/${type}/${productId}?${params}`);
        }
      }
    },
    checkout: {
      simulation: (args, {
        salesChannel
      } = ctx.storage.channel) => {
        const params = new URLSearchParams({
          sc: salesChannel
        });
        return fetchAPI(`${base}/api/checkout/pub/orderForms/simulation?${params.toString()}`, { ...BASE_INIT,
          body: JSON.stringify(args)
        });
      },
      orderForm: ({
        id,
        refreshOutdatedData = true,
        channel = ctx.storage.channel
      }) => {
        const {
          salesChannel
        } = channel;
        const params = new URLSearchParams({
          refreshOutdatedData: refreshOutdatedData.toString(),
          sc: salesChannel
        });
        return fetchAPI(`${base}/api/checkout/pub/orderForm/${id}?${params.toString()}`, BASE_INIT);
      },
      updateOrderFormItems: ({
        id,
        orderItems,
        allowOutdatedData = 'paymentData',
        salesChannel = ctx.storage.channel.salesChannel
      }) => {
        const params = new URLSearchParams({
          allowOutdatedData,
          sc: salesChannel
        });
        return fetchAPI(`${base}/api/checkout/pub/orderForm/${id}/items?${params}`, { ...BASE_INIT,
          body: JSON.stringify({
            orderItems
          }),
          method: 'PATCH'
        });
      },
      setCustomData: ({
        id,
        appId,
        key,
        value
      }) => {
        return fetchAPI(`${base}/api/checkout/pub/orderForm/${id}/customData/${appId}/${key}`, { ...BASE_INIT,
          body: JSON.stringify({
            value
          }),
          method: 'PUT'
        });
      },
      region: async ({
        postalCode,
        country,
        salesChannel
      }) => {
        return fetchAPI(`${base}/api/checkout/pub/regions/?postalCode=${postalCode}&country=${country}&sc=${salesChannel != null ? salesChannel : ''}`);
      }
    },
    session: search => {
      const params = new URLSearchParams(search);
      params.set('items', 'profile.id,profile.email,profile.firstName,profile.lastName,store.channel,store.countryCode,store.cultureInfo,store.currencyCode,store.currencySymbol');
      return fetchAPI(`${base}/api/sessions?${params.toString()}`, {
        method: 'POST',
        headers: {
          'content-type': 'application/json',
          cookie: ctx.headers.cookie
        },
        body: '{}'
      });
    }
  };
};

const POLICY_KEY = 'trade-policy';
const REGION_KEY = 'region-id';
const CHANNEL_KEYS = /*#__PURE__*/new Set([POLICY_KEY, REGION_KEY]);
const IntelligentSearch = ({
  account,
  environment,
  hideUnavailableItems
}, ctx) => {
  const base = `https://${account}.${environment}.com.br/api/io`;

  const getPolicyFacet = () => {
    const {
      salesChannel
    } = ctx.storage.channel;

    if (!salesChannel) {
      return null;
    }

    return {
      key: POLICY_KEY,
      value: salesChannel
    };
  };

  const getRegionFacet = () => {
    const {
      regionId
    } = ctx.storage.channel;

    if (!regionId) {
      return null;
    }

    return {
      key: REGION_KEY,
      value: regionId
    };
  };

  const addDefaultFacets = facets => {
    var _facets$find, _facets$find2;

    const withDefaltFacets = facets.filter(({
      key
    }) => !CHANNEL_KEYS.has(key));
    const policyFacet = (_facets$find = facets.find(({
      key
    }) => key === POLICY_KEY)) != null ? _facets$find : getPolicyFacet();
    const regionFacet = (_facets$find2 = facets.find(({
      key
    }) => key === REGION_KEY)) != null ? _facets$find2 : getRegionFacet();

    if (policyFacet !== null) {
      withDefaltFacets.push(policyFacet);
    }

    if (regionFacet !== null) {
      withDefaltFacets.push(regionFacet);
    }

    return withDefaltFacets;
  };

  const search = ({
    query = '',
    page,
    count,
    sort = '',
    selectedFacets = [],
    type,
    fuzzy = 'auto'
  }) => {
    const params = new URLSearchParams({
      page: (page + 1).toString(),
      count: count.toString(),
      query,
      sort,
      fuzzy,
      locale: ctx.storage.locale
    });

    if (hideUnavailableItems !== undefined) {
      params.append('hideUnavailableItems', hideUnavailableItems.toString());
    }

    const pathname = addDefaultFacets(selectedFacets).map(({
      key,
      value
    }) => `${key}/${value}`).join('/');
    return fetchAPI(`${base}/_v/api/intelligent-search/${type}/${pathname}?${params.toString()}`);
  };

  const products = args => search({ ...args,
    type: 'product_search'
  });

  const suggestedTerms = args => {
    var _args$query$toString, _args$query;

    const params = new URLSearchParams({
      query: (_args$query$toString = (_args$query = args.query) == null ? void 0 : _args$query.toString()) != null ? _args$query$toString : '',
      locale: ctx.storage.locale
    });
    return fetchAPI(`${base}/_v/api/intelligent-search/search_suggestions?${params.toString()}`);
  };

  const topSearches = () => {
    const params = new URLSearchParams({
      locale: ctx.storage.locale
    });
    return fetchAPI(`${base}/_v/api/intelligent-search/top_searches?${params.toString()}`);
  };

  const facets = args => search({ ...args,
    type: 'facets'
  });

  return {
    facets,
    products,
    suggestedTerms,
    topSearches
  };
};

/**
 * Client for SP, Intelligent search's analytics event API
 * More info at: https://www.notion.so/vtexhandbook/Event-API-Documentation-48eee26730cf4d7f80f8fd7262231f84
 */
const THIRTY_MINUTES_S = 30 * 60;
const ONE_YEAR_S = 365 * 24 * 3600;

const randomUUID = () => (Math.random() * 1e6).toFixed(0);

const timelapsed = past => (Date.now() - past) / 1e3;

const createId = expiresSecond => {
  let payload = randomUUID();
  let createdAt = Date.now();
  return () => {
    if (timelapsed(createdAt) > expiresSecond) {
      payload = randomUUID();
      createdAt = Date.now();
    }

    return payload;
  };
};

const user = {
  anonymous: /*#__PURE__*/createId(ONE_YEAR_S),
  session: /*#__PURE__*/createId(THIRTY_MINUTES_S)
};
const SP = ({
  account
}, _) => {
  const base = `https://sp.vtex.com/event-api/v1/${account}/event`;

  const sendEvent = options => {
    return fetchAPI(base, {
      method: 'POST',
      body: JSON.stringify({ ...options,
        agent: '@faststore/api',
        anonymous: user.anonymous(),
        session: user.session()
      }),
      headers: {
        'content-type': 'application/json'
      }
    });
  };

  return {
    sendEvent
  };
};

const getClients = (options, ctx) => {
  const search = IntelligentSearch(options, ctx);
  const commerce = VtexCommerce(options, ctx);
  const sp = SP(options);
  return {
    search,
    commerce,
    sp
  };
};

const getSalesChannelLoader = (_, clients) => {
  const loader = async channels => Promise.all(channels.map(sc => clients.commerce.catalog.salesChannel(sc)));

  return new DataLoader(loader);
};

const CONCURRENT_REQUESTS_MAX = 1;
const getSimulationLoader = (_, clients) => {
  const limit = pLimit(CONCURRENT_REQUESTS_MAX);

  const loader = async allItems => {
    const items = [...allItems.flat()];
    const simulation = await clients.commerce.checkout.simulation({
      items
    }); // Sort and filter simulation since Checkout API may return
    // items that we didn't ask for

    const simulated = simulation.items.reduce((acc, item) => {
      const index = item.requestIndex;

      if (typeof index === 'number' && index < acc.length) {
        acc[index] = item;
      }

      return acc;
    }, Array(items.length).fill(null));
    const itemsIndices = allItems.reduce((acc, curr) => [...acc, curr.length + acc[acc.length - 1]], [0]);
    return allItems.map((__, index) => ({ ...simulation,
      items: simulated.slice(itemsIndices[index], itemsIndices[index + 1]).filter(item => Boolean(item))
    }));
  };

  const limited = async allItems => limit(loader, allItems);

  return new DataLoader(limited, {
    maxBatchSize: 50
  });
};

const enhanceSku = (item, product) => ({ ...item,
  isVariantOf: product
});

class FastStoreError extends Error {
  constructor(extensions, message) {
    super(message);
    this.extensions = extensions;
    this.name = 'FastStoreError';
  }

}

class BadRequestError extends FastStoreError {
  constructor(message) {
    super({
      status: 400,
      type: 'BadRequestError'
    }, message);
  }

}
class NotFoundError extends FastStoreError {
  constructor(message) {
    super({
      status: 404,
      type: 'NotFoundError'
    }, message);
  }

}
const isFastStoreError = error => (error == null ? void 0 : error.name) === 'FastStoreError';
const isNotFoundError = error => {
  var _error$extensions;

  return (error == null ? void 0 : (_error$extensions = error.extensions) == null ? void 0 : _error$extensions.type) === 'NotFoundError';
};
const isBadRequestError = error => {
  var _error$extensions2;

  return (error == null ? void 0 : (_error$extensions2 = error.extensions) == null ? void 0 : _error$extensions2.type) === 'BadRequestError';
};

const getSkuLoader = (_, clients) => {
  const loader = async skuIds => {
    const {
      products
    } = await clients.search.products({
      query: `sku:${skuIds.join(';')}`,
      page: 0,
      count: skuIds.length
    });
    const skuBySkuId = products.reduce((acc, product) => {
      for (const sku of product.items) {
        acc[sku.itemId] = enhanceSku(sku, product);
      }

      return acc;
    }, {});
    const skus = skuIds.map(skuId => skuBySkuId[skuId]);
    const missingSkus = skuIds.filter(skuId => !skuBySkuId[skuId]);

    if (missingSkus.length > 0) {
      throw new NotFoundError(`Search API did not found the following skus: ${missingSkus.join(',')}`);
    }

    return skus;
  };

  return new DataLoader(loader, {
    maxBatchSize: 99
  });
};

const CONCURRENT_REQUESTS_MAX$1 = 20;
const collectionPageTypes = /*#__PURE__*/new Set(['brand', 'category', 'department', 'subcategory']);
const isCollectionPageType = x => typeof x.pageType === 'string' && collectionPageTypes.has(x.pageType.toLowerCase());
const getCollectionLoader = (_, clients) => {
  const limit = pLimit(CONCURRENT_REQUESTS_MAX$1);

  const loader = async slugs => {
    return Promise.all(slugs.map(slug => limit(async () => {
      const page = await clients.commerce.catalog.portal.pagetype(slug);

      if (isCollectionPageType(page)) {
        return page;
      }

      throw new NotFoundError(`Catalog returned ${page.pageType} for slug: ${slug}. This usually happens when there is more than one category with the same name in the same category tree level.`);
    })));
  };

  return new DataLoader(loader, {
    // DataLoader is being used to cache requests, not to batch them
    batch: false
  });
};

const getLoaders = (options, {
  clients
}) => {
  const skuLoader = getSkuLoader(options, clients);
  const simulationLoader = getSimulationLoader(options, clients);
  const collectionLoader = getCollectionLoader(options, clients);
  const salesChannelLoader = getSalesChannelLoader(options, clients);
  return {
    skuLoader,
    simulationLoader,
    collectionLoader,
    salesChannelLoader
  };
};

const inStock = offer => offer.AvailableQuantity > 0;
const price = offer => {
  var _offer$spotPrice;

  return (_offer$spotPrice = offer.spotPrice) != null ? _offer$spotPrice : 0;
};
const sellingPrice = offer => {
  var _offer$Price;

  return (_offer$Price = offer.Price) != null ? _offer$Price : 0;
};
const availability = available => available ? 'https://schema.org/InStock' : 'https://schema.org/OutOfStock'; // Smallest Available Spot Price First

const bestOfferFirst = (a, b) => {
  if (inStock(a) && !inStock(b)) {
    return -1;
  }

  if (!inStock(a) && inStock(b)) {
    return 1;
  }

  return price(a) - price(b);
};
const inStockOrderFormItem = itemAvailability => itemAvailability === 'available';

const StoreAggregateOffer = {
  highPrice: offers => {
    const availableOffers = offers.filter(inStock);
    const highOffer = availableOffers[availableOffers.length - 1];
    return highOffer != null ? price(highOffer) : 0;
  },
  lowPrice: offers => {
    const [lowOffer] = offers.filter(inStock);
    return lowOffer ? price(lowOffer) : 0;
  },
  offerCount: offers => offers.length,
  priceCurrency: async (_, __, ctx) => {
    var _sc$CurrencyCode;

    const {
      loaders: {
        salesChannelLoader
      },
      storage: {
        channel
      }
    } = ctx;
    const sc = await salesChannelLoader.load(channel.salesChannel);
    return (_sc$CurrencyCode = sc.CurrencyCode) != null ? _sc$CurrencyCode : '';
  },
  offers: offers => offers
};

// TODO: Add a review system integration
const StoreAggregateRating = {
  ratingValue: () => 5,
  reviewCount: () => 0
};

/* eslint-disable no-useless-escape */

/**
 * VTEX catalog slugify function
 *
 * Copied from:
 * https://github.com/vtex/rewriter/blob/1ce2010783e0586cab42534ce2fb7a983d8a3a84/node/clients/catalog.ts#L72
 *
 * Sometimes, we need to slugify strings for creating urls. An example is the
 * brand urls, where we create them from the brand's name.
 * This slugify function should match exactly what VTEX catalog generates. Any mismatch
 * will lead to broken links.
 * Hopefully, we had this function implemented on VTEX IO and we've been using it for
 * years now. However, looking at the code, I think we can save lots of computing. I'm
 * in a hurry for doing these tests now, so I'll leave a small TODO.
 *
 * TODO: Research for better ways of computing this slugify function. Things I'd try are:
 * - Join those 3 regexs for special characters into a single one.
 * - Replace the regexp of `removeDiacritics` function with a Map. We can make the complexity
 * of this function be O(n) with n=string.length
 *
 */
const from = 'ÁÄÂÀÃÅČÇĆĎÉĚËÈÊẼĔȆÍÌÎÏŇÑÓÖÒÔÕØŘŔŠŤÚŮÜÙÛÝŸŽáäâàãåčçćďéěëèêẽĕȇíìîïňñóöòôõøðřŕšťúůüùûýÿžþÞĐđßÆa';
const to = 'AAAAAACCCDEEEEEEEEIIIINNOOOOOORRSTUUUUUYYZaaaaaacccdeeeeeeeeiiiinnooooooorrstuuuuuyyzbBDdBAa';

const removeDiacritics = str => {
  let newStr = str.slice(0);

  for (let i = 0; i < from.length; i++) {
    newStr = newStr.replace(new RegExp(from.charAt(i), 'g'), to.charAt(i));
  }

  return newStr;
};

const slugifySpecialCharacters = str => {
  return str.replace(/[·/_,:]/, '-');
};

function slugify(str) {
  const noCommas = str.replace(/,/g, '');
  const replaced = noCommas.replace(/[*+~.()'"!:@&\[\]`/ %$#?{}|><=_^]/g, '-');
  const slugified = slugifySpecialCharacters(removeDiacritics(replaced));
  return slugified.toLowerCase();
}

const isBrand = x => x.type === 'brand' || isCollectionPageType(x) && x.pageType.toLowerCase() === 'brand';

const slugifyRoot = root => {
  if (isBrand(root)) {
    return slugify(root.name);
  }

  if (isCollectionPageType(root)) {
    return new URL(`https://${root.url}`).pathname.slice(1).toLowerCase();
  }

  return new URL(root.url).pathname.slice(1).toLowerCase();
};

const StoreCollection = {
  id: ({
    id
  }) => id.toString(),
  slug: root => slugifyRoot(root),
  seo: root => isBrand(root) || isCollectionPageType(root) ? {
    title: root.title,
    description: root.metaTagDescription
  } : {
    title: root.Title,
    description: root.MetaTagDescription
  },
  type: root => isBrand(root) ? 'Brand' : isCollectionPageType(root) ? root.pageType : root.level === 0 ? 'Department' : 'Category',
  meta: root => {
    const slug = slugifyRoot(root);
    return isBrand(root) ? {
      selectedFacets: [{
        key: 'brand',
        value: slug
      }]
    } : {
      selectedFacets: slug.split('/').map((segment, index) => ({
        key: `category-${index + 1}`,
        value: segment
      }))
    };
  },
  breadcrumbList: async (root, _, ctx) => {
    const {
      loaders: {
        collectionLoader
      }
    } = ctx;
    const slug = slugifyRoot(root);
    /**
     * Split slug into segments so we fetch all data for
     * the breadcrumb. For instance, if we get `/foo/bar`
     * we need all metadata for both `/foo` and `/bar` and
     * thus we need to fetch pageType for `/foo` and `/bar`
     */

    const segments = slug.split('/').filter(segment => Boolean(segment));
    const slugs = segments.map((__, index) => segments.slice(0, index + 1).join('/'));
    const collections = await Promise.all(slugs.map(s => collectionLoader.load(s)));
    return {
      itemListElement: collections.map((collection, index) => ({
        item: new URL(`https://${collection.url}`).pathname.toLowerCase(),
        name: collection.name,
        position: index + 1
      })),
      numberOfItems: collections.length
    };
  }
};

class ChannelMarshal {
  static parse(channelString) {
    try {
      var _parsedChannel$region, _parsedChannel$salesC;

      const parsedChannel = JSON.parse(channelString);
      return {
        regionId: (_parsedChannel$region = parsedChannel.regionId) != null ? _parsedChannel$region : '',
        salesChannel: (_parsedChannel$salesC = parsedChannel.salesChannel) != null ? _parsedChannel$salesC : ''
      };
    } catch (error) {
      console.error(error);
      throw new Error('Malformed channel string');
    }
  }

  static stringify(channel) {
    return JSON.stringify(channel);
  }

}

const FACET_CROSS_SELLING_MAP = {
  buy: "whoboughtalsobought",
  view: "whosawalsosaw",
  similars: "similars",
  viewAndBought: "whosawalsobought",
  accessories: "accessories",
  suggestions: "suggestions"
};
/**
 * Transform facets from the store to VTEX platform facets.
 * For instance, the channel in Store becomes trade-policy and regionId in VTEX's realm
 * */

const transformSelectedFacet = ({
  key,
  value
}) => {
  switch (key) {
    case 'channel':
      {
        const channel = ChannelMarshal.parse(value);
        const channelFacets = [{
          key: 'trade-policy',
          value: channel.salesChannel
        }];

        if (channel.regionId) {
          channelFacets.push({
            key: 'region-id',
            value: channel.regionId
          });
        }

        return channelFacets;
      }

    case 'locale':
      {
        return []; // remove this facet from search
      }

    case 'price':
      {
        return {
          key,
          value: value.replace('-to-', ':')
        };
      }

    case "buy":
    case "view":
    case "similars":
    case "viewAndBought":
    case "accessories":
    case "suggestions":
      {
        return []; // remove this facet from search
      }

    default:
      return {
        key,
        value
      };
  }
};
const parseRange = range => {
  const splitted = range.split(':').map(Number);

  if (splitted.length !== 2 || Number.isNaN(splitted[0]) || Number.isNaN(splitted[1])) {
    return null;
  }

  return splitted;
};
const isCrossSelling = x => typeof FACET_CROSS_SELLING_MAP[x] === "string";
const findCrossSelling = facets => {
  var _filtered$;

  const filtered = facets == null ? void 0 : facets.filter(x => isCrossSelling(x.key));

  if (Array.isArray(filtered) && filtered.length > 1) {
    throw new BadRequestError(`You passed ${filtered.length} cross selling facets but only one is allowed. Please leave one of the following facet: ${filtered.map(x => x.key).join(',')}`);
  }

  return (_filtered$ = filtered == null ? void 0 : filtered[0]) != null ? _filtered$ : null;
};
const findSlug = facets => {
  var _facets$find$value, _facets$find;

  return (_facets$find$value = facets == null ? void 0 : (_facets$find = facets.find(x => x.key === 'slug')) == null ? void 0 : _facets$find.value) != null ? _facets$find$value : null;
};
const findSkuId = facets => {
  var _facets$find$value2, _facets$find2;

  return (_facets$find$value2 = facets == null ? void 0 : (_facets$find2 = facets.find(x => x.key === 'id')) == null ? void 0 : _facets$find2.value) != null ? _facets$find$value2 : null;
};
const findLocale = facets => {
  var _facets$find$value3, _facets$find3;

  return (_facets$find$value3 = facets == null ? void 0 : (_facets$find3 = facets.find(x => x.key === 'locale')) == null ? void 0 : _facets$find3.value) != null ? _facets$find$value3 : null;
};
const findChannel = facets => {
  var _facets$find$value4, _facets$find4;

  return (_facets$find$value4 = facets == null ? void 0 : (_facets$find4 = facets.find(facet => facet.key === 'channel')) == null ? void 0 : _facets$find4.value) != null ? _facets$find$value4 : null;
};

/**
 * More info at: https://en.wikipedia.org/wiki/Order_statistic
 */
// O(n) search to find the max of an array
const min = (array, cmp) => {
  let best = 0;

  for (let curr = 1; curr < array.length; curr++) {
    if (cmp(array[best], array[curr]) > 0) {
      best = curr;
    }
  }

  return array[best];
};

const StoreFacet = {
  __resolveType: ({
    type
  }) => type === 'TEXT' ? 'StoreFacetBoolean' : 'StoreFacetRange'
};
const StoreFacetBoolean = {
  key: ({
    key
  }) => key,
  label: ({
    name
  }) => name,
  values: ({
    values
  }) => values.sort((a, b) => a.name.localeCompare(b.name))
};
const StoreFacetRange = {
  key: ({
    key
  }) => key,
  label: ({
    name
  }) => name,
  min: ({
    values,
    key
  }, _, {
    storage: {
      searchArgs
    }
  }) => {
    var _searchArgs$selectedF, _searchArgs$selectedF2, _searchArgs$selectedF3, _facet$range$from, _selectedRange$;

    /**
     * Fetch the selected range the user queried.
     *
     * This is necessary because, differently from boolean facets, Search API does
     * not return the selected values, making us have to implement it in here
     */
    const selectedRange = parseRange((_searchArgs$selectedF = searchArgs == null ? void 0 : (_searchArgs$selectedF2 = searchArgs.selectedFacets) == null ? void 0 : (_searchArgs$selectedF3 = _searchArgs$selectedF2.find(facet => facet.key === key)) == null ? void 0 : _searchArgs$selectedF3.value) != null ? _searchArgs$selectedF : '');
    const facet = min(values, (a, b) => a.range.from - b.range.from);
    const globalMin = (_facet$range$from = facet == null ? void 0 : facet.range.from) != null ? _facet$range$from : 0;
    return {
      selected: (_selectedRange$ = selectedRange == null ? void 0 : selectedRange[0]) != null ? _selectedRange$ : globalMin,
      absolute: globalMin
    };
  },
  max: ({
    values,
    key
  }, _, {
    storage: {
      searchArgs
    }
  }) => {
    var _searchArgs$selectedF4, _searchArgs$selectedF5, _searchArgs$selectedF6, _facet$range$to, _selectedRange$2;

    /**
     * Fetch the selected range the user queried.
     *
     * This is necessary because, differently from boolean facets, Search API does
     * not return the selected values, making us have to implement it in here
     */
    const selectedRange = parseRange((_searchArgs$selectedF4 = searchArgs == null ? void 0 : (_searchArgs$selectedF5 = searchArgs.selectedFacets) == null ? void 0 : (_searchArgs$selectedF6 = _searchArgs$selectedF5.find(facet => facet.key === key)) == null ? void 0 : _searchArgs$selectedF6.value) != null ? _searchArgs$selectedF4 : '');
    const facet = min(values, (a, b) => b.range.to - a.range.to);
    const globalMax = (_facet$range$to = facet == null ? void 0 : facet.range.to) != null ? _facet$range$to : 0;
    return {
      selected: (_selectedRange$2 = selectedRange == null ? void 0 : selectedRange[1]) != null ? _selectedRange$2 : globalMax,
      absolute: globalMax
    };
  }
};

const StoreFacetValueBoolean = {
  value: ({
    value
  }) => value,
  label: ({
    name
  }) => name || 'unknown',
  selected: ({
    selected
  }) => selected,
  quantity: ({
    quantity
  }) => quantity
};

const md5 = payload => crypto.createHash('md5').update(payload).digest('hex');

const VALUE_REFERENCES = {
  attachment: 'ATTACHMENT',
  specification: 'SPECIFICATION'
};
function attachmentToPropertyValue(attachment) {
  return {
    name: attachment.name,
    value: attachment.content,
    valueReference: VALUE_REFERENCES.attachment
  };
}
function getPropertyId(item) {
  return md5(`${item.name}:${JSON.stringify(item.value)}:${item.valueReference}`);
}

const isAttachment = value => value.valueReference === VALUE_REFERENCES.attachment;

const getId = item => {
  var _item$itemOffered$add;

  return [item.itemOffered.sku, item.seller.identifier, item.price, (_item$itemOffered$add = item.itemOffered.additionalProperty) == null ? void 0 : _item$itemOffered$add.filter(isAttachment).map(getPropertyId).join('-')].filter(Boolean).join('::');
};

const orderFormItemToOffer = (item, index) => ({
  listPrice: item.listPrice / 100,
  price: item.sellingPrice / 100,
  quantity: item.quantity,
  seller: {
    identifier: item.seller
  },
  itemOffered: {
    sku: item.id,
    image: [],
    name: item.name,
    additionalProperty: item.attachments.map(attachmentToPropertyValue)
  },
  index
});

const offerToOrderItemInput = offer => {
  var _offer$itemOffered$ad, _offer$itemOffered$ad2;

  return {
    quantity: offer.quantity,
    seller: offer.seller.identifier,
    id: offer.itemOffered.sku,
    index: offer.index,
    attachments: ((_offer$itemOffered$ad = (_offer$itemOffered$ad2 = offer.itemOffered.additionalProperty) == null ? void 0 : _offer$itemOffered$ad2.filter(isAttachment)) != null ? _offer$itemOffered$ad : []).map(attachment => ({
      name: attachment.name,
      content: attachment.value
    }))
  };
};

const groupById = offers => offers.reduce((acc, item) => {
  var _acc$get;

  const id = getId(item);
  acc.set(id, (_acc$get = acc.get(id)) != null ? _acc$get : item);
  return acc;
}, new Map());

const equals = (storeOrder, orderForm) => {
  const pick = (item, index) => ({ ...item,
    itemOffered: {
      sku: item.itemOffered.sku
    },
    index
  });

  const orderFormItems = orderForm.items.map(orderFormItemToOffer).map(pick);
  const storeOrderItems = storeOrder.acceptedOffer.map(pick);
  const isSameOrder = storeOrder.orderNumber === orderForm.orderFormId;
  const orderItemsAreSync = deepEquals(orderFormItems, storeOrderItems);
  return isSameOrder && orderItemsAreSync;
};

const orderFormToCart = async (form, skuLoader) => {
  return {
    order: {
      orderNumber: form.orderFormId,
      acceptedOffer: form.items.map(async item => ({ ...item,
        product: await skuLoader.load(item.id)
      }))
    },
    messages: form.messages.map(({
      text,
      status
    }) => ({
      text,
      status: status.toUpperCase()
    }))
  };
};

const getOrderFormEtag = ({
  items
}) => md5(JSON.stringify(items));

const setOrderFormEtag = async (form, commerce) => {
  try {
    const orderForm = await commerce.checkout.setCustomData({
      id: form.orderFormId,
      appId: 'faststore',
      key: 'cartEtag',
      value: getOrderFormEtag(form)
    });
    return orderForm;
  } catch (err) {
    console.error('Error while setting custom data to orderForm.\n Make sure to add the following custom app to the orderForm: \n{"fields":["cartEtag"],"id":"faststore","major":1}.\n More info at: https://developers.vtex.com/vtex-rest-api/docs/customizable-fields-with-checkout-api');
    throw err;
  }
};
/**
 * Checks if cartEtag stored on customData is up to date
 * @description If cartEtag is not up to date, this means that
 * another system changed the cart, like Checkout UI or Order Placed
 */


const isOrderFormStale = form => {
  var _form$customData, _faststoreData$fields;

  const faststoreData = (_form$customData = form.customData) == null ? void 0 : _form$customData.customApps.find(app => app.id === 'faststore');
  const oldEtag = faststoreData == null ? void 0 : (_faststoreData$fields = faststoreData.fields) == null ? void 0 : _faststoreData$fields.cartEtag;

  if (oldEtag == null) {
    return true;
  }

  const newEtag = getOrderFormEtag(form);
  return newEtag !== oldEtag;
};
/**
 * This resolver implements the optimistic cart behavior. The main idea in here
 * is that we receive a cart from the UI (as query params) and we validate it with
 * the commerce platform. If the cart is valid, we return null, if the cart is
 * invalid according to the commerce platform, we return the new cart the UI should use
 * instead.
 *
 * The algorithm is something like:
 * 1. Fetch orderForm from VTEX
 * 2. Compute delta changes between the orderForm and the UI's cart
 * 3. Update the orderForm in VTEX platform accordingly
 * 4. If any changes were made, send to the UI the new cart. Null otherwise
 */


const validateCart = async (_, {
  cart: {
    order
  }
}, ctx) => {
  const {
    enableOrderFormSync
  } = ctx.storage.flags;
  const {
    orderNumber,
    acceptedOffer
  } = order;
  const {
    clients: {
      commerce
    },
    loaders: {
      skuLoader
    }
  } = ctx; // Step1: Get OrderForm from VTEX Commerce

  const orderForm = await commerce.checkout.orderForm({
    id: orderNumber
  }); // Step1.5: Check if another system changed the orderForm with this orderNumber
  // If so, this means the user interacted with this cart elsewhere and expects
  // to see this new cart state instead of what's stored on the user's browser.

  if (enableOrderFormSync === true) {
    const isStale = isOrderFormStale(orderForm);

    if (isStale === true && orderNumber) {
      const newOrderForm = await setOrderFormEtag(orderForm, commerce);
      return orderFormToCart(newOrderForm, skuLoader);
    }
  } // Step2: Process items from both browser and checkout so they have the same shape


  const browserItemsById = groupById(acceptedOffer);
  const originItemsById = groupById(orderForm.items.map(orderFormItemToOffer));
  const browserItems = Array.from(browserItemsById.values()); // items on the user's browser

  const originItems = Array.from(originItemsById.values()); // items on the VTEX platform backend
  // Step3: Compute delta changes

  const {
    itemsToAdd,
    itemsToUpdate
  } = browserItems.reduce((acc, item) => {
    const maybeOriginItem = originItemsById.get(getId(item));

    if (!maybeOriginItem) {
      acc.itemsToAdd.push(item);
    } else {
      acc.itemsToUpdate.push({ ...maybeOriginItem,
        quantity: item.quantity
      });
    }

    return acc;
  }, {
    itemsToAdd: [],
    itemsToUpdate: []
  });
  const itemsToDelete = originItems.filter(item => !browserItemsById.has(getId(item))).map(item => ({ ...item,
    quantity: 0
  }));
  const changes = [...itemsToAdd, ...itemsToUpdate, ...itemsToDelete].map(offerToOrderItemInput);

  if (changes.length === 0) {
    return null;
  } // Step4: Apply delta changes to order form


  const updatedOrderForm = await commerce.checkout // update orderForm items
  .updateOrderFormItems({
    id: orderForm.orderFormId,
    orderItems: changes
  }) // update orderForm etag so we know last time we touched this orderForm
  .then(form => enableOrderFormSync ? setOrderFormEtag(form, commerce) : form); // Step5: If no changes detected before/after updating orderForm, the order is validated

  if (equals(order, updatedOrderForm)) {
    return null;
  } // Step6: There were changes, convert orderForm to StoreCart


  return orderFormToCart(updatedOrderForm, skuLoader);
};

const validateSession = async (_, {
  session: oldSession,
  search
}, {
  clients
}) => {
  var _oldSession$channel, _oldSession$postalCod, _oldSession$country, _params$get, _sessionData$namespac, _sessionData$namespac2, _store$currencyCode$v, _store$currencySymbol, _store$countryCode$va, _store$channel$value, _store$channel, _regionData$0$id, _regionData$, _profile$id$value, _profile$id, _profile$email$value, _profile$email, _profile$firstName$va, _profile$firstName, _profile$lastName$val, _profile$lastName;

  const channel = ChannelMarshal.parse((_oldSession$channel = oldSession.channel) != null ? _oldSession$channel : '');
  const postalCode = String((_oldSession$postalCod = oldSession.postalCode) != null ? _oldSession$postalCod : '').replace(/\D/g, '');
  const country = (_oldSession$country = oldSession.country) != null ? _oldSession$country : '';
  const params = new URLSearchParams(search);
  params.set('sc', (_params$get = params.get('sc')) != null ? _params$get : channel.salesChannel);
  const [regionData, sessionData] = await Promise.all([postalCode ? clients.commerce.checkout.region({
    postalCode,
    country
  }) : Promise.resolve(null), clients.commerce.session(params.toString()).catch(() => null)]);
  const profile = (_sessionData$namespac = sessionData == null ? void 0 : sessionData.namespaces.profile) != null ? _sessionData$namespac : null;
  const store = (_sessionData$namespac2 = sessionData == null ? void 0 : sessionData.namespaces.store) != null ? _sessionData$namespac2 : null;
  const newSession = { ...oldSession,
    currency: {
      code: (_store$currencyCode$v = store == null ? void 0 : store.currencyCode.value) != null ? _store$currencyCode$v : oldSession.currency.code,
      symbol: (_store$currencySymbol = store == null ? void 0 : store.currencySymbol.value) != null ? _store$currencySymbol : oldSession.currency.symbol
    },
    country: (_store$countryCode$va = store == null ? void 0 : store.countryCode.value) != null ? _store$countryCode$va : oldSession.country,
    channel: ChannelMarshal.stringify({
      salesChannel: (_store$channel$value = store == null ? void 0 : (_store$channel = store.channel) == null ? void 0 : _store$channel.value) != null ? _store$channel$value : channel.salesChannel,
      regionId: (_regionData$0$id = regionData == null ? void 0 : (_regionData$ = regionData[0]) == null ? void 0 : _regionData$.id) != null ? _regionData$0$id : channel.regionId
    }),
    person: profile != null && profile.id ? {
      id: (_profile$id$value = (_profile$id = profile.id) == null ? void 0 : _profile$id.value) != null ? _profile$id$value : '',
      email: (_profile$email$value = (_profile$email = profile.email) == null ? void 0 : _profile$email.value) != null ? _profile$email$value : '',
      givenName: (_profile$firstName$va = (_profile$firstName = profile.firstName) == null ? void 0 : _profile$firstName.value) != null ? _profile$firstName$va : '',
      familyName: (_profile$lastName$val = (_profile$lastName = profile.lastName) == null ? void 0 : _profile$lastName.value) != null ? _profile$lastName$val : ''
    } : null
  };

  if (deepEquals(oldSession, newSession)) {
    return null;
  }

  return newSession;
};

const Mutation = {
  validateCart,
  validateSession
};

const ObjectOrString = /*#__PURE__*/new GraphQLScalarType({
  name: 'ObjectOrString',
  description: 'A string or the string representation of an object (a stringified object).',
  parseValue: toObjectOrString,
  serialize: stringify,

  parseLiteral(ast) {
    if (ast.kind === Kind.STRING) {
      return getValueAsObjectOrString(ast.value);
    }

    return null;
  }

});

function toObjectOrString(value) {
  if (typeof value === 'string') {
    return getValueAsObjectOrString(value);
  }

  return null;
}

function getValueAsObjectOrString(value) {
  try {
    return JSON.parse(value);
  } catch (e) {
    return value;
  }
}

function stringify(value) {
  if (typeof value === 'object') {
    return JSON.stringify(value);
  }

  if (typeof value === 'string') {
    return value;
  }

  return null;
}

const isSearchItem = item => 'Price' in item && 'seller' in item && 'product' in item;

const isOrderFormItem = item => 'skuName' in item;

const StoreOffer = {
  priceCurrency: async (_, __, ctx) => {
    var _sc$CurrencyCode;

    const {
      loaders: {
        salesChannelLoader
      },
      storage: {
        channel
      }
    } = ctx;
    const sc = await salesChannelLoader.load(channel.salesChannel);
    return (_sc$CurrencyCode = sc.CurrencyCode) != null ? _sc$CurrencyCode : '';
  },
  priceValidUntil: root => {
    if (isSearchItem(root)) {
      var _root$PriceValidUntil;

      return (_root$PriceValidUntil = root.PriceValidUntil) != null ? _root$PriceValidUntil : '';
    }

    if (isOrderFormItem(root)) {
      var _root$priceValidUntil;

      return (_root$priceValidUntil = root.priceValidUntil) != null ? _root$priceValidUntil : '';
    }

    return null;
  },
  itemCondition: () => 'https://schema.org/NewCondition',
  availability: async root => {
    if (isSearchItem(root)) {
      return availability(inStock(root));
    }

    if (isOrderFormItem(root)) {
      return availability(inStockOrderFormItem(root.availability));
    }

    return null;
  },
  seller: root => {
    if (isSearchItem(root)) {
      var _root$seller$sellerId;

      return {
        identifier: (_root$seller$sellerId = root.seller.sellerId) != null ? _root$seller$sellerId : ''
      };
    }

    if (isOrderFormItem(root)) {
      return {
        identifier: root.seller
      };
    }

    return null;
  },
  price: root => {
    if (isSearchItem(root)) {
      return price(root);
    }

    if (isOrderFormItem(root)) {
      return root.sellingPrice / 1e2;
    }

    return null;
  },
  sellingPrice: root => {
    if (isSearchItem(root)) {
      return sellingPrice(root);
    }

    if (isOrderFormItem(root)) {
      return root.sellingPrice / 1e2;
    }

    return null;
  },
  listPrice: root => {
    if (isSearchItem(root)) {
      var _root$ListPrice;

      return (_root$ListPrice = root.ListPrice) != null ? _root$ListPrice : 0;
    }

    if (isOrderFormItem(root)) {
      return root.listPrice / 1e2;
    }

    return null;
  },
  itemOffered: root => {
    if (isSearchItem(root)) {
      return root.product;
    }

    if (isOrderFormItem(root)) {
      return { ...root.product,
        attachmentsValues: root.attachments
      };
    }

    return null;
  },
  quantity: root => {
    if (isSearchItem(root)) {
      var _root$AvailableQuanti;

      return (_root$AvailableQuanti = root.AvailableQuantity) != null ? _root$AvailableQuanti : 0;
    }

    if (isOrderFormItem(root)) {
      return root.quantity;
    }

    return null;
  }
};

const canonicalFromProduct = ({
  linkText
}) => `/${linkText}/p`;

const enhanceCommercialOffer = ({
  offer,
  seller,
  product
}) => ({ ...offer,
  product,
  seller
});

const DEFAULT_IMAGE = {
  imageText: 'image',
  imageUrl: 'https://storecomponents.vtexassets.com/assets/faststore/images/image___117a6d3e229a96ad0e0d0876352566e2.svg'
};

const getSlug = (link, id) => `${link}-${id}`;

const getPath = (link, id) => `/${getSlug(link, id)}/p`;

const nonEmptyArray = array => Array.isArray(array) && array.length > 0 ? array : null;

const StoreProduct = {
  productID: ({
    itemId
  }) => itemId,
  name: ({
    isVariantOf,
    name
  }) => name != null ? name : isVariantOf.productName,
  slug: ({
    isVariantOf: {
      linkText
    },
    itemId
  }) => getSlug(linkText, itemId),
  description: ({
    isVariantOf: {
      description
    }
  }) => description,
  seo: ({
    isVariantOf
  }) => ({
    title: isVariantOf.productName,
    description: isVariantOf.description,
    canonical: canonicalFromProduct(isVariantOf)
  }),
  brand: ({
    isVariantOf: {
      brand
    }
  }) => ({
    name: brand
  }),
  breadcrumbList: ({
    isVariantOf: {
      categories,
      productName,
      linkText
    },
    itemId
  }) => {
    return {
      itemListElement: [...categories.reverse().map((categoryPath, index) => {
        const splitted = categoryPath.split('/');
        const name = splitted[splitted.length - 2];
        const item = splitted.map(slugify).join('/');
        return {
          name,
          item,
          position: index + 1
        };
      }), {
        name: productName,
        item: getPath(linkText, itemId),
        position: categories.length + 1
      }],
      numberOfItems: categories.length
    };
  },
  image: ({
    images
  }) => {
    var _nonEmptyArray;

    return ((_nonEmptyArray = nonEmptyArray(images)) != null ? _nonEmptyArray : [DEFAULT_IMAGE]).map(({
      imageUrl,
      imageText
    }) => ({
      alternateName: imageText != null ? imageText : '',
      url: imageUrl.replace('vteximg.com.br', 'vtexassets.com')
    }));
  },
  sku: ({
    itemId
  }) => itemId,
  gtin: ({
    referenceId
  }) => {
    var _referenceId$0$Value, _referenceId$;

    return (_referenceId$0$Value = (_referenceId$ = referenceId[0]) == null ? void 0 : _referenceId$.Value) != null ? _referenceId$0$Value : '';
  },
  review: () => [],
  aggregateRating: () => ({}),
  offers: root => root.sellers.map(seller => enhanceCommercialOffer({
    offer: seller.commertialOffer,
    seller,
    product: root
  })).sort(bestOfferFirst),
  isVariantOf: root => root,
  additionalProperty: ({
    // Search uses the name variations for specifications
    variations: specifications = [],
    attachmentsValues = []
  }) => {
    const propertyValueSpecifications = specifications.flatMap(({
      name,
      values
    }) => values.map(value => ({
      name,
      value,
      valueReference: VALUE_REFERENCES.specification
    })));
    const propertyValueAttachments = attachmentsValues.map(attachmentToPropertyValue);
    return [...propertyValueSpecifications, ...propertyValueAttachments];
  }
};

const BLOCKED_SPECIFICATIONS = /*#__PURE__*/new Set(['allSpecifications']);
const StoreProductGroup = {
  hasVariant: root => root.isVariantOf.items.map(item => enhanceSku(item, root.isVariantOf)),
  productGroupID: ({
    isVariantOf
  }) => isVariantOf.productId,
  name: ({
    isVariantOf
  }) => isVariantOf.productName,
  additionalProperty: ({
    isVariantOf: {
      specificationGroups
    }
  }) => specificationGroups // filter sku specifications so we dont mess sku with product specs
  .filter(specificationGroup => !BLOCKED_SPECIFICATIONS.has(specificationGroup.name)) // Transform specs back into product specs
  .flatMap(({
    specifications
  }) => specifications.flatMap(({
    name,
    values
  }) => values.map(value => ({
    name,
    value,
    valueReference: VALUE_REFERENCES.specification
  }))))
};

const StorePropertyValue = {
  propertyID: root => getPropertyId(root),
  name: ({
    name
  }) => name,
  value: ({
    value
  }) => value,
  valueReference: ({
    valueReference
  }) => valueReference
};

const mutateChannelContext = (ctx, channelString) => {
  ctx.storage.channel = ChannelMarshal.parse(channelString);
};
const mutateLocaleContext = (ctx, locale) => {
  ctx.storage.locale = locale;
};

const SORT_MAP = {
  price_desc: 'price:desc',
  price_asc: 'price:asc',
  orders_desc: 'orders:desc',
  name_desc: 'name:desc',
  name_asc: 'name:asc',
  release_desc: 'release:desc',
  discount_desc: 'discount:desc',
  score_desc: ''
};

/**
 * This function implements Portal heuristics for returning the best sku for a product.
 *
 * The best sku is the one with the best (cheapest available) offer
 * */

const pickBestSku = skus => {
  const offersBySku = skus.flatMap(sku => sku.sellers.map(seller => ({
    offer: seller.commertialOffer,
    sku
  })));
  const best = min(offersBySku, ({
    offer: o1
  }, {
    offer: o2
  }) => bestOfferFirst(o1, o2));
  return best.sku;
};
const isValidSkuId = skuId => skuId !== '' && !Number.isNaN(Number(skuId));

const Query = {
  product: async (_, {
    locator
  }, ctx) => {
    // Insert channel in context for later usage
    const channel = findChannel(locator);
    const locale = findLocale(locator);
    const id = findSkuId(locator);
    const slug = findSlug(locator);

    if (channel) {
      mutateChannelContext(ctx, channel);
    }

    if (locale) {
      mutateLocaleContext(ctx, locale);
    }

    const {
      loaders: {
        skuLoader
      },
      clients: {
        commerce,
        search
      }
    } = ctx;

    try {
      var _ref;

      const skuId = (_ref = id != null ? id : slug == null ? void 0 : slug.split('-').pop()) != null ? _ref : '';

      if (!isValidSkuId(skuId)) {
        throw new Error('Invalid SkuId');
      }

      const sku = await skuLoader.load(skuId);
      return sku;
    } catch (err) {
      if (slug == null) {
        throw new BadRequestError('Missing slug or id');
      }

      const route = await commerce.catalog.portal.pagetype(`${slug}/p`);

      if (route.pageType !== 'Product' || !route.id) {
        throw new NotFoundError(`No product found for slug ${slug}`);
      }

      const {
        products: [product]
      } = await search.products({
        page: 0,
        count: 1,
        query: `product:${route.id}`
      });

      if (!product) {
        throw new NotFoundError(`No product found for id ${route.id}`);
      }

      const sku = pickBestSku(product.items);
      return enhanceSku(sku, product);
    }
  },
  collection: (_, {
    slug
  }, ctx) => {
    const {
      loaders: {
        collectionLoader
      }
    } = ctx;
    return collectionLoader.load(slug);
  },
  search: async (_, {
    first,
    after: maybeAfter,
    sort,
    term,
    selectedFacets
  }, ctx) => {
    var _selectedFacets$flatM;

    // Insert channel in context for later usage
    const channel = findChannel(selectedFacets);
    const locale = findLocale(selectedFacets);
    const crossSelling = findCrossSelling(selectedFacets);

    if (channel) {
      mutateChannelContext(ctx, channel);
    }

    if (locale) {
      mutateLocaleContext(ctx, locale);
    }

    let query = term;
    /**
     * In case we are using crossSelling, we need to modify the search
     * we will be performing on our search engine. The idea in here
     * is to use the cross selling API for fetching the productIds our
     * search will return for us.
     * Doing this two request workflow makes it possible to have cross
     * selling with Search features, like pagination, internationalization
     * etc
     */

    if (crossSelling) {
      const products = await ctx.clients.commerce.catalog.products.crossselling({
        type: FACET_CROSS_SELLING_MAP[crossSelling.key],
        productId: crossSelling.value
      });
      query = `product:${products.map(x => x.productId).slice(0, first).join(";")}`;
    }

    const after = maybeAfter ? Number(maybeAfter) : 0;
    const searchArgs = {
      page: Math.ceil(after / first),
      count: first,
      query,
      sort: SORT_MAP[sort != null ? sort : 'score_desc'],
      selectedFacets: (_selectedFacets$flatM = selectedFacets == null ? void 0 : selectedFacets.flatMap(transformSelectedFacet)) != null ? _selectedFacets$flatM : []
    };
    return searchArgs;
  },
  allProducts: async (_, {
    first,
    after: maybeAfter
  }, ctx) => {
    const {
      clients: {
        search
      }
    } = ctx;
    const after = maybeAfter ? Number(maybeAfter) : 0;
    const products = await search.products({
      page: Math.ceil(after / first),
      count: first
    });
    const skus = products.products.map(product => product.items.map(sku => enhanceSku(sku, product))).flat().filter(sku => sku.sellers.length > 0);
    return {
      pageInfo: {
        hasNextPage: products.pagination.after.length > 0,
        hasPreviousPage: products.pagination.before.length > 0,
        startCursor: '0',
        endCursor: products.recordsFiltered.toString(),
        totalCount: products.recordsFiltered
      },
      // after + index is bigger than after+first itself because of the array flat() above
      edges: skus.map((sku, index) => ({
        node: sku,
        cursor: (after + index).toString()
      }))
    };
  },
  allCollections: async (_, {
    first,
    after: maybeAfter
  }, ctx) => {
    const {
      clients: {
        commerce
      }
    } = ctx;
    const after = maybeAfter ? Number(maybeAfter) : 0;
    const [brands, tree] = await Promise.all([commerce.catalog.brand.list(), commerce.catalog.category.tree()]);
    const categories = [];

    const dfs = (node, level) => {
      categories.push({ ...node,
        level
      });

      for (const child of node.children) {
        dfs(child, level + 1);
      }
    };

    for (const node of tree) {
      dfs(node, 0);
    }

    const collections = [...brands.filter(brand => brand.isActive).map(x => ({ ...x,
      type: 'brand'
    })), ...categories];
    const validCollections = collections // Nullable slugs may cause one route to override the other
    .filter(node => Boolean(StoreCollection.slug(node, null, ctx, null)));
    return {
      pageInfo: {
        hasNextPage: validCollections.length - after > first,
        hasPreviousPage: after > 0,
        startCursor: '0',
        endCursor: (Math.min(first, validCollections.length - after) - 1).toString(),
        totalCount: validCollections.length
      },
      edges: validCollections.slice(after, after + first).map((node, index) => ({
        node,
        cursor: (after + index).toString()
      }))
    };
  }
};

const StoreReview = {
  reviewRating: () => ({
    ratingValue: 5,
    bestRating: 5
  }),
  author: () => ({
    name: ''
  })
};

const isRootFacet = facet => facet.key === 'category-1';

const StoreSearchResult = {
  suggestions: async (searchArgs, _, ctx) => {
    const {
      clients: {
        search
      }
    } = ctx; // If there's no search query, suggest the most popular searches.

    if (!searchArgs.query) {
      const topSearches = await search.topSearches();
      return {
        terms: topSearches.searches.map(item => ({
          value: item.term,
          count: item.count
        })),
        products: []
      };
    }

    const terms = await search.suggestedTerms(searchArgs);
    const products = await search.products(searchArgs);
    const skus = products.products.map(product => {
      const [maybeSku] = product.items;
      return maybeSku && enhanceSku(maybeSku, product);
    }).filter(sku => !!sku);
    const {
      searches
    } = terms;
    return {
      terms: searches.map(item => ({
        value: item.term,
        count: item.count
      })),
      products: skus
    };
  },
  products: async (searchArgs, _, ctx) => {
    const {
      clients: {
        search,
        sp
      }
    } = ctx;
    const products = await search.products(searchArgs); // Raise event on search's analytics API when performing
    // a full text search.

    if (searchArgs.query) {
      sp.sendEvent({
        type: 'search.query',
        text: searchArgs.query,
        misspelled: products.correction.misspelled,
        match: products.recordsFiltered,
        operator: products.operator
      }).catch(console.error);
    }

    const skus = products.products.map(product => {
      const [maybeSku] = product.items;
      return maybeSku && enhanceSku(maybeSku, product);
    }).filter(sku => !!sku);
    return {
      pageInfo: {
        hasNextPage: products.pagination.after.length > 0,
        hasPreviousPage: products.pagination.before.length > 0,
        startCursor: '0',
        endCursor: products.recordsFiltered.toString(),
        totalCount: products.recordsFiltered
      },
      edges: skus.map((sku, index) => ({
        node: sku,
        cursor: index.toString()
      }))
    };
  },
  facets: async (searchArgs, _, ctx) => {
    const {
      clients: {
        search: is
      }
    } = ctx;
    ctx.storage.searchArgs = searchArgs;
    const {
      facets = []
    } = await is.facets(searchArgs);
    const isCollectionPage = !searchArgs.query;
    const filteredFacets = facets // Remove root facet on category pages
    .filter(facet => !isCollectionPage || !isRootFacet(facet));
    return filteredFacets;
  }
};

const StoreSeo = {
  title: ({
    title
  }) => title != null ? title : '',
  description: ({
    description
  }) => description != null ? description : '',
  canonical: ({
    canonical
  }) => canonical != null ? canonical : '',
  titleTemplate: () => ''
};

const Resolvers = {
  StoreCollection,
  StoreAggregateOffer,
  StoreProduct,
  StoreSeo,
  StoreFacet,
  StoreFacetBoolean,
  StoreFacetRange,
  StoreFacetValueBoolean,
  StoreOffer,
  StoreAggregateRating,
  StoreReview,
  StoreProductGroup,
  StoreSearchResult,
  StorePropertyValue,
  ObjectOrString,
  Query,
  Mutation
};
const getContextFactory = options => ctx => {
  var _options$flags;

  ctx.storage = {
    channel: ChannelMarshal.parse(options.channel),
    flags: (_options$flags = options.flags) != null ? _options$flags : {},
    locale: options.locale
  };
  ctx.clients = getClients(options, ctx);
  ctx.loaders = getLoaders(options, ctx);
  return ctx;
};
const getResolvers = _ => Resolvers;

var doc = {"kind":"Document","definitions":[{"kind":"ObjectTypeDefinition","description":{"kind":"StringValue","value":"Aggregate offer information, for a given SKU that is available to be fulfilled by multiple sellers.","block":true},"name":{"kind":"Name","value":"StoreAggregateOffer"},"interfaces":[],"directives":[],"fields":[{"kind":"FieldDefinition","description":{"kind":"StringValue","value":"Highest price among all sellers.","block":true},"name":{"kind":"Name","value":"highPrice"},"arguments":[],"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"Float"}}},"directives":[]},{"kind":"FieldDefinition","description":{"kind":"StringValue","value":"Lowest price among all sellers.","block":true},"name":{"kind":"Name","value":"lowPrice"},"arguments":[],"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"Float"}}},"directives":[]},{"kind":"FieldDefinition","description":{"kind":"StringValue","value":"Number of sellers selling this SKU.","block":true},"name":{"kind":"Name","value":"offerCount"},"arguments":[],"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"Int"}}},"directives":[]},{"kind":"FieldDefinition","description":{"kind":"StringValue","value":"ISO code of the currency used for the offer prices.","block":true},"name":{"kind":"Name","value":"priceCurrency"},"arguments":[],"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"String"}}},"directives":[]},{"kind":"FieldDefinition","description":{"kind":"StringValue","value":"Array with information on each available offer.","block":true},"name":{"kind":"Name","value":"offers"},"arguments":[],"type":{"kind":"NonNullType","type":{"kind":"ListType","type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"StoreOffer"}}}}},"directives":[]}]}],"loc":{"start":0,"end":516}};
    doc.loc.source = {"body":"\"\"\"\nAggregate offer information, for a given SKU that is available to be fulfilled by multiple sellers.\n\"\"\"\ntype StoreAggregateOffer {\n  \"\"\"\n  Highest price among all sellers.\n  \"\"\"\n  highPrice: Float!\n  \"\"\"\n  Lowest price among all sellers.\n  \"\"\"\n  lowPrice: Float!\n  \"\"\"\n  Number of sellers selling this SKU.\n  \"\"\"\n  offerCount: Int!\n  \"\"\"\n  ISO code of the currency used for the offer prices.\n  \"\"\"\n  priceCurrency: String!\n  \"\"\"\n  Array with information on each available offer.\n  \"\"\"\n  offers: [StoreOffer!]!\n}\n","name":"GraphQL request","locationOffset":{"line":1,"column":1}};

var doc$1 = {"kind":"Document","definitions":[{"kind":"ObjectTypeDefinition","description":{"kind":"StringValue","value":"Average rating, based on multiple ratings or reviews.","block":true},"name":{"kind":"Name","value":"StoreAggregateRating"},"interfaces":[],"directives":[],"fields":[{"kind":"FieldDefinition","description":{"kind":"StringValue","value":"Value of the aggregate rating.","block":true},"name":{"kind":"Name","value":"ratingValue"},"arguments":[],"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"Float"}}},"directives":[]},{"kind":"FieldDefinition","description":{"kind":"StringValue","value":"Total number of ratings.","block":true},"name":{"kind":"Name","value":"reviewCount"},"arguments":[],"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"Int"}}},"directives":[]}]}],"loc":{"start":0,"end":218}};
    doc$1.loc.source = {"body":"\"\"\"\nAverage rating, based on multiple ratings or reviews.\n\"\"\"\ntype StoreAggregateRating {\n  \"\"\"\n  Value of the aggregate rating.\n  \"\"\"\n  ratingValue: Float!\n  \"\"\"\n  Total number of ratings.\n  \"\"\"\n  reviewCount: Int!\n}\n","name":"GraphQL request","locationOffset":{"line":1,"column":1}};

var doc$2 = {"kind":"Document","definitions":[{"kind":"ObjectTypeDefinition","description":{"kind":"StringValue","value":"information about the author of a product review or rating.","block":true},"name":{"kind":"Name","value":"StoreAuthor"},"interfaces":[],"directives":[],"fields":[{"kind":"FieldDefinition","description":{"kind":"StringValue","value":"Author name.","block":true},"name":{"kind":"Name","value":"name"},"arguments":[],"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"String"}}},"directives":[]}]}],"loc":{"start":0,"end":132}};
    doc$2.loc.source = {"body":"\"\"\"\ninformation about the author of a product review or rating.\n\"\"\"\ntype StoreAuthor {\n  \"\"\"\n  Author name.\n  \"\"\"\n  name: String!\n}\n","name":"GraphQL request","locationOffset":{"line":1,"column":1}};

var doc$3 = {"kind":"Document","definitions":[{"kind":"ObjectTypeDefinition","description":{"kind":"StringValue","value":"Brand of a given product.","block":true},"name":{"kind":"Name","value":"StoreBrand"},"interfaces":[],"directives":[],"fields":[{"kind":"FieldDefinition","description":{"kind":"StringValue","value":"Brand name.","block":true},"name":{"kind":"Name","value":"name"},"arguments":[],"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"String"}}},"directives":[]}]}],"loc":{"start":0,"end":96}};
    doc$3.loc.source = {"body":"\"\"\"\nBrand of a given product.\n\"\"\"\ntype StoreBrand {\n  \"\"\"\n  Brand name.\n  \"\"\"\n  name: String!\n}\n","name":"GraphQL request","locationOffset":{"line":1,"column":1}};

var doc$4 = {"kind":"Document","definitions":[{"kind":"ObjectTypeDefinition","description":{"kind":"StringValue","value":"Item of a list.","block":true},"name":{"kind":"Name","value":"StoreListItem"},"interfaces":[],"directives":[],"fields":[{"kind":"FieldDefinition","description":{"kind":"StringValue","value":"List item value.","block":true},"name":{"kind":"Name","value":"item"},"arguments":[],"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"String"}}},"directives":[]},{"kind":"FieldDefinition","description":{"kind":"StringValue","value":"Name of the list item.","block":true},"name":{"kind":"Name","value":"name"},"arguments":[],"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"String"}}},"directives":[]},{"kind":"FieldDefinition","description":{"kind":"StringValue","value":"Position of the item in the list.","block":true},"name":{"kind":"Name","value":"position"},"arguments":[],"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"Int"}}},"directives":[]}]},{"kind":"ObjectTypeDefinition","description":{"kind":"StringValue","value":"List of items consisting of chain linked web pages, ending with the current page.","block":true},"name":{"kind":"Name","value":"StoreBreadcrumbList"},"interfaces":[],"directives":[],"fields":[{"kind":"FieldDefinition","description":{"kind":"StringValue","value":"Array with breadcrumb elements.","block":true},"name":{"kind":"Name","value":"itemListElement"},"arguments":[],"type":{"kind":"NonNullType","type":{"kind":"ListType","type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"StoreListItem"}}}}},"directives":[]},{"kind":"FieldDefinition","description":{"kind":"StringValue","value":"Number of breadcrumbs in the list.","block":true},"name":{"kind":"Name","value":"numberOfItems"},"arguments":[],"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"Int"}}},"directives":[]}]}],"loc":{"start":0,"end":486}};
    doc$4.loc.source = {"body":"\"\"\"\nItem of a list.\n\"\"\"\ntype StoreListItem {\n  \"\"\"\n  List item value.\n  \"\"\"\n  item: String!\n  \"\"\"\n  Name of the list item.\n  \"\"\"\n  name: String!\n  \"\"\"\n  Position of the item in the list.\n  \"\"\"\n  position: Int!\n}\n\n\"\"\"\nList of items consisting of chain linked web pages, ending with the current page.\n\"\"\"\ntype StoreBreadcrumbList {\n  \"\"\"\n  Array with breadcrumb elements.\n  \"\"\"\n  itemListElement: [StoreListItem!]!\n  \"\"\"\n  Number of breadcrumbs in the list.\n  \"\"\"\n  numberOfItems: Int!\n}\n","name":"GraphQL request","locationOffset":{"line":1,"column":1}};

var doc$5 = {"kind":"Document","definitions":[{"kind":"EnumTypeDefinition","description":{"kind":"StringValue","value":"Product collection type. Possible values are `Department`, `Category`, `Brand` or `Cluster`.","block":true},"name":{"kind":"Name","value":"StoreCollectionType"},"directives":[],"values":[{"kind":"EnumValueDefinition","description":{"kind":"StringValue","value":"First level of product categorization.","block":true},"name":{"kind":"Name","value":"Department"},"directives":[]},{"kind":"EnumValueDefinition","description":{"kind":"StringValue","value":"Second level of product categorization.","block":true},"name":{"kind":"Name","value":"Category"},"directives":[]},{"kind":"EnumValueDefinition","description":{"kind":"StringValue","value":"Product brand.","block":true},"name":{"kind":"Name","value":"Brand"},"directives":[]},{"kind":"EnumValueDefinition","description":{"kind":"StringValue","value":"Product cluster.","block":true},"name":{"kind":"Name","value":"Cluster"},"directives":[]}]},{"kind":"ObjectTypeDefinition","description":{"kind":"StringValue","value":"Product collection facet, used for search.","block":true},"name":{"kind":"Name","value":"StoreCollectionFacet"},"interfaces":[],"directives":[],"fields":[{"kind":"FieldDefinition","description":{"kind":"StringValue","value":"Facet key.","block":true},"name":{"kind":"Name","value":"key"},"arguments":[],"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"String"}}},"directives":[]},{"kind":"FieldDefinition","description":{"kind":"StringValue","value":"Facet value.","block":true},"name":{"kind":"Name","value":"value"},"arguments":[],"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"String"}}},"directives":[]}]},{"kind":"ObjectTypeDefinition","description":{"kind":"StringValue","value":"Collection meta information. Used for search.","block":true},"name":{"kind":"Name","value":"StoreCollectionMeta"},"interfaces":[],"directives":[],"fields":[{"kind":"FieldDefinition","description":{"kind":"StringValue","value":"List of selected collection facets.","block":true},"name":{"kind":"Name","value":"selectedFacets"},"arguments":[],"type":{"kind":"NonNullType","type":{"kind":"ListType","type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"StoreCollectionFacet"}}}}},"directives":[]}]},{"kind":"ObjectTypeDefinition","description":{"kind":"StringValue","value":"Product collection information.","block":true},"name":{"kind":"Name","value":"StoreCollection"},"interfaces":[],"directives":[],"fields":[{"kind":"FieldDefinition","description":{"kind":"StringValue","value":"Meta tag data.","block":true},"name":{"kind":"Name","value":"seo"},"arguments":[],"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"StoreSeo"}}},"directives":[]},{"kind":"FieldDefinition","description":{"kind":"StringValue","value":"List of items consisting of chain linked web pages, ending with the current page.","block":true},"name":{"kind":"Name","value":"breadcrumbList"},"arguments":[],"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"StoreBreadcrumbList"}}},"directives":[]},{"kind":"FieldDefinition","description":{"kind":"StringValue","value":"Collection meta information. Used for search.","block":true},"name":{"kind":"Name","value":"meta"},"arguments":[],"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"StoreCollectionMeta"}}},"directives":[]},{"kind":"FieldDefinition","description":{"kind":"StringValue","value":"Collection ID.","block":true},"name":{"kind":"Name","value":"id"},"arguments":[],"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"ID"}}},"directives":[]},{"kind":"FieldDefinition","description":{"kind":"StringValue","value":"Corresponding collection URL slug, with which to retrieve this entity.","block":true},"name":{"kind":"Name","value":"slug"},"arguments":[],"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"String"}}},"directives":[]},{"kind":"FieldDefinition","description":{"kind":"StringValue","value":"Collection type.","block":true},"name":{"kind":"Name","value":"type"},"arguments":[],"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"StoreCollectionType"}}},"directives":[]}]}],"loc":{"start":0,"end":1218}};
    doc$5.loc.source = {"body":"\"\"\"\nProduct collection type. Possible values are `Department`, `Category`, `Brand` or `Cluster`.\n\"\"\"\nenum StoreCollectionType {\n  \"\"\"\n  First level of product categorization.\n  \"\"\"\n  Department\n  \"\"\"\n  Second level of product categorization.\n  \"\"\"\n  Category\n  \"\"\"\n  Product brand.\n  \"\"\"\n  Brand\n  \"\"\"\n  Product cluster.\n  \"\"\"\n  Cluster\n}\n\n\"\"\"\nProduct collection facet, used for search.\n\"\"\"\ntype StoreCollectionFacet {\n  \"\"\"\n  Facet key.\n  \"\"\"\n  key: String!\n  \"\"\"\n  Facet value.\n  \"\"\"\n  value: String!\n}\n\n\"\"\"\nCollection meta information. Used for search.\n\"\"\"\ntype StoreCollectionMeta {\n  \"\"\"\n  List of selected collection facets.\n  \"\"\"\n  selectedFacets: [StoreCollectionFacet!]!\n}\n\n\"\"\"\nProduct collection information.\n\"\"\"\ntype StoreCollection {\n  \"\"\"\n  Meta tag data.\n  \"\"\"\n  seo: StoreSeo!\n  \"\"\"\n  List of items consisting of chain linked web pages, ending with the current page.\n  \"\"\"\n  breadcrumbList: StoreBreadcrumbList!\n  \"\"\"\n  Collection meta information. Used for search.\n  \"\"\"\n  meta: StoreCollectionMeta!\n  \"\"\"\n  Collection ID.\n  \"\"\"\n  id: ID!\n  \"\"\"\n  Corresponding collection URL slug, with which to retrieve this entity.\n  \"\"\"\n  slug: String!\n  \"\"\"\n  Collection type.\n  \"\"\"\n  type: StoreCollectionType!\n}\n","name":"GraphQL request","locationOffset":{"line":1,"column":1}};

var doc$6 = {"kind":"Document","definitions":[{"kind":"UnionTypeDefinition","name":{"kind":"Name","value":"StoreFacet"},"directives":[],"types":[{"kind":"NamedType","name":{"kind":"Name","value":"StoreFacetRange"}},{"kind":"NamedType","name":{"kind":"Name","value":"StoreFacetBoolean"}}]},{"kind":"ObjectTypeDefinition","description":{"kind":"StringValue","value":"Search facet range information.","block":true},"name":{"kind":"Name","value":"StoreFacetRange"},"interfaces":[],"directives":[],"fields":[{"kind":"FieldDefinition","description":{"kind":"StringValue","value":"Facet key.","block":true},"name":{"kind":"Name","value":"key"},"arguments":[],"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"String"}}},"directives":[]},{"kind":"FieldDefinition","description":{"kind":"StringValue","value":"Facet label.","block":true},"name":{"kind":"Name","value":"label"},"arguments":[],"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"String"}}},"directives":[]},{"kind":"FieldDefinition","description":{"kind":"StringValue","value":"Minimum facet range value.","block":true},"name":{"kind":"Name","value":"min"},"arguments":[],"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"StoreFacetValueRange"}}},"directives":[]},{"kind":"FieldDefinition","description":{"kind":"StringValue","value":"Maximum facet range value.","block":true},"name":{"kind":"Name","value":"max"},"arguments":[],"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"StoreFacetValueRange"}}},"directives":[]}]},{"kind":"ObjectTypeDefinition","description":{"kind":"StringValue","value":"Search facet boolean information.","block":true},"name":{"kind":"Name","value":"StoreFacetBoolean"},"interfaces":[],"directives":[],"fields":[{"kind":"FieldDefinition","description":{"kind":"StringValue","value":"Facet key.","block":true},"name":{"kind":"Name","value":"key"},"arguments":[],"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"String"}}},"directives":[]},{"kind":"FieldDefinition","description":{"kind":"StringValue","value":"Facet label.","block":true},"name":{"kind":"Name","value":"label"},"arguments":[],"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"String"}}},"directives":[]},{"kind":"FieldDefinition","description":{"kind":"StringValue","value":"Array with information on each facet value.","block":true},"name":{"kind":"Name","value":"values"},"arguments":[],"type":{"kind":"NonNullType","type":{"kind":"ListType","type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"StoreFacetValueBoolean"}}}}},"directives":[]}]},{"kind":"ObjectTypeDefinition","description":{"kind":"StringValue","value":"Search facet range value information. Used for minimum and maximum range values.","block":true},"name":{"kind":"Name","value":"StoreFacetValueRange"},"interfaces":[],"directives":[],"fields":[{"kind":"FieldDefinition","description":{"kind":"StringValue","value":"Search facet range absolute value.","block":true},"name":{"kind":"Name","value":"absolute"},"arguments":[],"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"Float"}}},"directives":[]},{"kind":"FieldDefinition","description":{"kind":"StringValue","value":"Search facet range selected value.","block":true},"name":{"kind":"Name","value":"selected"},"arguments":[],"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"Float"}}},"directives":[]}]},{"kind":"ObjectTypeDefinition","description":{"kind":"StringValue","value":"Information of a specific facet value.","block":true},"name":{"kind":"Name","value":"StoreFacetValueBoolean"},"interfaces":[],"directives":[],"fields":[{"kind":"FieldDefinition","description":{"kind":"StringValue","value":"Facet value.","block":true},"name":{"kind":"Name","value":"value"},"arguments":[],"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"String"}}},"directives":[]},{"kind":"FieldDefinition","description":{"kind":"StringValue","value":"Facet value label.","block":true},"name":{"kind":"Name","value":"label"},"arguments":[],"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"String"}}},"directives":[]},{"kind":"FieldDefinition","description":{"kind":"StringValue","value":"Indicates whether facet is selected.","block":true},"name":{"kind":"Name","value":"selected"},"arguments":[],"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"Boolean"}}},"directives":[]},{"kind":"FieldDefinition","description":{"kind":"StringValue","value":"Number of items with this facet.","block":true},"name":{"kind":"Name","value":"quantity"},"arguments":[],"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"Int"}}},"directives":[]}]}],"loc":{"start":0,"end":1160}};
    doc$6.loc.source = {"body":"union StoreFacet = StoreFacetRange | StoreFacetBoolean\n\n\"\"\"\nSearch facet range information.\n\"\"\"\ntype StoreFacetRange {\n  \"\"\"\n  Facet key.\n  \"\"\"\n  key: String!\n  \"\"\"\n  Facet label.\n  \"\"\"\n  label: String!\n  \"\"\"\n  Minimum facet range value.\n  \"\"\"\n  min: StoreFacetValueRange!\n  \"\"\"\n  Maximum facet range value.\n  \"\"\"\n  max: StoreFacetValueRange!\n}\n\n\"\"\"\nSearch facet boolean information.\n\"\"\"\ntype StoreFacetBoolean {\n  \"\"\"\n  Facet key.\n  \"\"\"\n  key: String!\n  \"\"\"\n  Facet label.\n  \"\"\"\n  label: String!\n  \"\"\"\n  Array with information on each facet value.\n  \"\"\"\n  values: [StoreFacetValueBoolean!]!\n}\n\n\"\"\"\nSearch facet range value information. Used for minimum and maximum range values.\n\"\"\"\ntype StoreFacetValueRange {\n  \"\"\"\n  Search facet range absolute value.\n  \"\"\"\n  absolute: Float!\n  \"\"\"\n  Search facet range selected value.\n  \"\"\"\n  selected: Float!\n}\n\n\"\"\"\nInformation of a specific facet value.\n\"\"\"\ntype StoreFacetValueBoolean {\n  \"\"\"\n  Facet value.\n  \"\"\"\n  value: String!\n  \"\"\"\n  Facet value label.\n  \"\"\"\n  label: String!\n  \"\"\"\n  Indicates whether facet is selected.\n  \"\"\"\n  selected: Boolean!\n  \"\"\"\n  Number of items with this facet.\n  \"\"\"\n  quantity: Int!\n}\n","name":"GraphQL request","locationOffset":{"line":1,"column":1}};

var doc$7 = {"kind":"Document","definitions":[{"kind":"ObjectTypeDefinition","description":{"kind":"StringValue","value":"Image.","block":true},"name":{"kind":"Name","value":"StoreImage"},"interfaces":[],"directives":[],"fields":[{"kind":"FieldDefinition","description":{"kind":"StringValue","value":"Image URL.","block":true},"name":{"kind":"Name","value":"url"},"arguments":[],"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"String"}}},"directives":[]},{"kind":"FieldDefinition","description":{"kind":"StringValue","value":"Alias for the image.","block":true},"name":{"kind":"Name","value":"alternateName"},"arguments":[],"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"String"}}},"directives":[]}]},{"kind":"InputObjectTypeDefinition","description":{"kind":"StringValue","value":"Image input.","block":true},"name":{"kind":"Name","value":"IStoreImage"},"directives":[],"fields":[{"kind":"InputValueDefinition","description":{"kind":"StringValue","value":"Image input URL.","block":true},"name":{"kind":"Name","value":"url"},"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"String"}}},"directives":[]},{"kind":"InputValueDefinition","description":{"kind":"StringValue","value":"Alias for the input image.","block":true},"name":{"kind":"Name","value":"alternateName"},"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"String"}}},"directives":[]}]}],"loc":{"start":0,"end":291}};
    doc$7.loc.source = {"body":"\"\"\"\nImage.\n\"\"\"\ntype StoreImage {\n  \"\"\"\n  Image URL.\n  \"\"\"\n  url: String!\n  \"\"\"\n  Alias for the image.\n  \"\"\"\n  alternateName: String!\n}\n\n\"\"\"\nImage input.\n\"\"\"\ninput IStoreImage {\n  \"\"\"\n  Image input URL.\n  \"\"\"\n  url: String!\n  \"\"\"\n  Alias for the input image.\n  \"\"\"\n  alternateName: String!\n}\n","name":"GraphQL request","locationOffset":{"line":1,"column":1}};

var doc$8 = {"kind":"Document","definitions":[{"kind":"ObjectTypeDefinition","name":{"kind":"Name","value":"Mutation"},"interfaces":[],"directives":[],"fields":[{"kind":"FieldDefinition","description":{"kind":"StringValue","value":"Checks for changes between the cart presented in the UI and the cart stored in the ecommerce platform. If changes are detected, it returns the cart stored on the platform. Otherwise, it returns `null`.","block":true},"name":{"kind":"Name","value":"validateCart"},"arguments":[{"kind":"InputValueDefinition","name":{"kind":"Name","value":"cart"},"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"IStoreCart"}}},"directives":[]}],"type":{"kind":"NamedType","name":{"kind":"Name","value":"StoreCart"}},"directives":[]},{"kind":"FieldDefinition","description":{"kind":"StringValue","value":"Updates a web session with the specified values.","block":true},"name":{"kind":"Name","value":"validateSession"},"arguments":[{"kind":"InputValueDefinition","name":{"kind":"Name","value":"session"},"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"IStoreSession"}}},"directives":[]},{"kind":"InputValueDefinition","name":{"kind":"Name","value":"search"},"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"String"}}},"directives":[]}],"type":{"kind":"NamedType","name":{"kind":"Name","value":"StoreSession"}},"directives":[]}]}],"loc":{"start":0,"end":416}};
    doc$8.loc.source = {"body":"type Mutation {\n  \"\"\"\n  Checks for changes between the cart presented in the UI and the cart stored in the ecommerce platform. If changes are detected, it returns the cart stored on the platform. Otherwise, it returns `null`.\n  \"\"\"\n  validateCart(cart: IStoreCart!): StoreCart\n  \"\"\"\n  Updates a web session with the specified values.\n  \"\"\"\n  validateSession(session: IStoreSession!, search: String!): StoreSession\n}\n","name":"GraphQL request","locationOffset":{"line":1,"column":1}};

var doc$9 = {"kind":"Document","definitions":[{"kind":"ObjectTypeDefinition","description":{"kind":"StringValue","value":"Offer information.","block":true},"name":{"kind":"Name","value":"StoreOffer"},"interfaces":[],"directives":[],"fields":[{"kind":"FieldDefinition","description":{"kind":"StringValue","value":"This is displayed as the \"from\" price in the context of promotions' price comparison. This may change before it reaches the shelf.","block":true},"name":{"kind":"Name","value":"listPrice"},"arguments":[],"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"Float"}}},"directives":[]},{"kind":"FieldDefinition","description":{"kind":"StringValue","value":"Computed price before applying coupons, taxes or benefits. This may change before it reaches the shelf.","block":true},"name":{"kind":"Name","value":"sellingPrice"},"arguments":[],"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"Float"}}},"directives":[]},{"kind":"FieldDefinition","description":{"kind":"StringValue","value":"ISO code of the currency used for the offer prices.","block":true},"name":{"kind":"Name","value":"priceCurrency"},"arguments":[],"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"String"}}},"directives":[]},{"kind":"FieldDefinition","description":{"kind":"StringValue","value":"Also known as spot price.","block":true},"name":{"kind":"Name","value":"price"},"arguments":[],"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"Float"}}},"directives":[]},{"kind":"FieldDefinition","description":{"kind":"StringValue","value":"Next date in which price is scheduled to change. If there is no scheduled change, this will be set a year in the future from current time.","block":true},"name":{"kind":"Name","value":"priceValidUntil"},"arguments":[],"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"String"}}},"directives":[]},{"kind":"FieldDefinition","description":{"kind":"StringValue","value":"Offer item condition.","block":true},"name":{"kind":"Name","value":"itemCondition"},"arguments":[],"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"String"}}},"directives":[]},{"kind":"FieldDefinition","description":{"kind":"StringValue","value":"Offer item availability.","block":true},"name":{"kind":"Name","value":"availability"},"arguments":[],"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"String"}}},"directives":[]},{"kind":"FieldDefinition","description":{"kind":"StringValue","value":"Seller responsible for the offer.","block":true},"name":{"kind":"Name","value":"seller"},"arguments":[],"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"StoreOrganization"}}},"directives":[]},{"kind":"FieldDefinition","description":{"kind":"StringValue","value":"Information on the item being offered.","block":true},"name":{"kind":"Name","value":"itemOffered"},"arguments":[],"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"StoreProduct"}}},"directives":[]},{"kind":"FieldDefinition","description":{"kind":"StringValue","value":"Number of items offered.","block":true},"name":{"kind":"Name","value":"quantity"},"arguments":[],"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"Int"}}},"directives":[]}]},{"kind":"InputObjectTypeDefinition","description":{"kind":"StringValue","value":"Offer input.","block":true},"name":{"kind":"Name","value":"IStoreOffer"},"directives":[],"fields":[{"kind":"InputValueDefinition","description":{"kind":"StringValue","value":"Also known as spot price.","block":true},"name":{"kind":"Name","value":"price"},"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"Float"}}},"directives":[]},{"kind":"InputValueDefinition","description":{"kind":"StringValue","value":"This is displayed as the \"from\" price in the context of promotions' price comparison. This may change before it reaches the shelf.","block":true},"name":{"kind":"Name","value":"listPrice"},"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"Float"}}},"directives":[]},{"kind":"InputValueDefinition","description":{"kind":"StringValue","value":"Seller responsible for the offer.","block":true},"name":{"kind":"Name","value":"seller"},"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"IStoreOrganization"}}},"directives":[]},{"kind":"InputValueDefinition","description":{"kind":"StringValue","value":"Information on the item being offered.","block":true},"name":{"kind":"Name","value":"itemOffered"},"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"IStoreProduct"}}},"directives":[]},{"kind":"InputValueDefinition","description":{"kind":"StringValue","value":"Number of items offered.","block":true},"name":{"kind":"Name","value":"quantity"},"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"Int"}}},"directives":[]}]}],"loc":{"start":0,"end":1501}};
    doc$9.loc.source = {"body":"\"\"\"\nOffer information.\n\"\"\"\ntype StoreOffer {\n  \"\"\"\n  This is displayed as the \"from\" price in the context of promotions' price comparison. This may change before it reaches the shelf.\n  \"\"\"\n  listPrice: Float!\n  \"\"\"\n  Computed price before applying coupons, taxes or benefits. This may change before it reaches the shelf.\n  \"\"\"\n  sellingPrice: Float!\n  \"\"\"\n  ISO code of the currency used for the offer prices.\n  \"\"\"\n  priceCurrency: String!\n  \"\"\"\n  Also known as spot price.\n  \"\"\"\n  price: Float!\n  \"\"\"\n  Next date in which price is scheduled to change. If there is no scheduled change, this will be set a year in the future from current time.\n  \"\"\"\n  priceValidUntil: String!\n  \"\"\"\n  Offer item condition.\n  \"\"\"\n  itemCondition: String!\n  \"\"\"\n  Offer item availability.\n  \"\"\"\n  availability: String!\n  \"\"\"\n  Seller responsible for the offer.\n  \"\"\"\n  seller: StoreOrganization!\n  \"\"\"\n  Information on the item being offered.\n  \"\"\"\n  itemOffered: StoreProduct!\n  \"\"\"\n  Number of items offered.\n  \"\"\"\n  quantity: Int!\n}\n\n\"\"\"\nOffer input.\n\"\"\"\ninput IStoreOffer {\n  \"\"\"\n  Also known as spot price.\n  \"\"\"\n  price: Float!\n  \"\"\"\n  This is displayed as the \"from\" price in the context of promotions' price comparison. This may change before it reaches the shelf.\n  \"\"\"\n  listPrice: Float!\n  \"\"\"\n  Seller responsible for the offer.\n  \"\"\"\n  seller: IStoreOrganization!\n  \"\"\"\n  Information on the item being offered.\n  \"\"\"\n  itemOffered: IStoreProduct!\n  \"\"\"\n  Number of items offered.\n  \"\"\"\n  quantity: Int!\n}\n","name":"GraphQL request","locationOffset":{"line":1,"column":1}};

var doc$a = {"kind":"Document","definitions":[{"kind":"ObjectTypeDefinition","description":{"kind":"StringValue","value":"Information of a specific order.","block":true},"name":{"kind":"Name","value":"StoreOrder"},"interfaces":[],"directives":[],"fields":[{"kind":"FieldDefinition","description":{"kind":"StringValue","value":"ID of the order in [VTEX order management](https://help.vtex.com/en/tutorial/license-manager-resources-oms--60QcBsvWeum02cFi3GjBzg#).","block":true},"name":{"kind":"Name","value":"orderNumber"},"arguments":[],"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"String"}}},"directives":[]},{"kind":"FieldDefinition","description":{"kind":"StringValue","value":"Array with information on each accepted offer.","block":true},"name":{"kind":"Name","value":"acceptedOffer"},"arguments":[],"type":{"kind":"NonNullType","type":{"kind":"ListType","type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"StoreOffer"}}}}},"directives":[]}]},{"kind":"InputObjectTypeDefinition","description":{"kind":"StringValue","value":"Order input.","block":true},"name":{"kind":"Name","value":"IStoreOrder"},"directives":[],"fields":[{"kind":"InputValueDefinition","description":{"kind":"StringValue","value":"ID of the order in [VTEX order management](https://help.vtex.com/en/tutorial/license-manager-resources-oms--60QcBsvWeum02cFi3GjBzg#).","block":true},"name":{"kind":"Name","value":"orderNumber"},"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"String"}}},"directives":[]},{"kind":"InputValueDefinition","description":{"kind":"StringValue","value":"Array with information on each accepted offer.","block":true},"name":{"kind":"Name","value":"acceptedOffer"},"type":{"kind":"NonNullType","type":{"kind":"ListType","type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"IStoreOffer"}}}}},"directives":[]}]}],"loc":{"start":0,"end":634}};
    doc$a.loc.source = {"body":"\"\"\"\nInformation of a specific order.\n\"\"\"\ntype StoreOrder {\n  \"\"\"\n  ID of the order in [VTEX order management](https://help.vtex.com/en/tutorial/license-manager-resources-oms--60QcBsvWeum02cFi3GjBzg#).\n  \"\"\"\n  orderNumber: String!\n  \"\"\"\n  Array with information on each accepted offer.\n  \"\"\"\n  acceptedOffer: [StoreOffer!]!\n}\n\n\"\"\"\nOrder input.\n\"\"\"\ninput IStoreOrder {\n  \"\"\"\n  ID of the order in [VTEX order management](https://help.vtex.com/en/tutorial/license-manager-resources-oms--60QcBsvWeum02cFi3GjBzg#).\n  \"\"\"\n  orderNumber: String!\n  \"\"\"\n  Array with information on each accepted offer.\n  \"\"\"\n  acceptedOffer: [IStoreOffer!]!\n}\n","name":"GraphQL request","locationOffset":{"line":1,"column":1}};

var doc$b = {"kind":"Document","definitions":[{"kind":"ObjectTypeDefinition","description":{"kind":"StringValue","value":"Organization.","block":true},"name":{"kind":"Name","value":"StoreOrganization"},"interfaces":[],"directives":[],"fields":[{"kind":"FieldDefinition","description":{"kind":"StringValue","value":"Organization ID.","block":true},"name":{"kind":"Name","value":"identifier"},"arguments":[],"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"String"}}},"directives":[]}]},{"kind":"InputObjectTypeDefinition","description":{"kind":"StringValue","value":"Organization input.","block":true},"name":{"kind":"Name","value":"IStoreOrganization"},"directives":[],"fields":[{"kind":"InputValueDefinition","description":{"kind":"StringValue","value":"Organization ID.","block":true},"name":{"kind":"Name","value":"identifier"},"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"String"}}},"directives":[]}]}],"loc":{"start":0,"end":213}};
    doc$b.loc.source = {"body":"\"\"\"\nOrganization.\n\"\"\"\ntype StoreOrganization {\n  \"\"\"\n  Organization ID.\n  \"\"\"\n  identifier: String!\n}\n\n\"\"\"\nOrganization input.\n\"\"\"\ninput IStoreOrganization {\n  \"\"\"\n  Organization ID.\n  \"\"\"\n  identifier: String!\n}\n","name":"GraphQL request","locationOffset":{"line":1,"column":1}};

var doc$c = {"kind":"Document","definitions":[{"kind":"ObjectTypeDefinition","description":{"kind":"StringValue","value":"Whenever you make a query that allows for pagination, such as `allProducts` or `allCollections`, you can check `StorePageInfo` to learn more about the complete set of items and use it to paginate your queries.","block":true},"name":{"kind":"Name","value":"StorePageInfo"},"interfaces":[],"directives":[],"fields":[{"kind":"FieldDefinition","description":{"kind":"StringValue","value":"Indicates whether there is at least one more page with items after the ones returned in the current query.","block":true},"name":{"kind":"Name","value":"hasNextPage"},"arguments":[],"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"Boolean"}}},"directives":[]},{"kind":"FieldDefinition","description":{"kind":"StringValue","value":"Indicates whether there is at least one more page with items before the ones returned in the current query.","block":true},"name":{"kind":"Name","value":"hasPreviousPage"},"arguments":[],"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"Boolean"}}},"directives":[]},{"kind":"FieldDefinition","description":{"kind":"StringValue","value":"Cursor corresponding to the first possible item.","block":true},"name":{"kind":"Name","value":"startCursor"},"arguments":[],"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"String"}}},"directives":[]},{"kind":"FieldDefinition","description":{"kind":"StringValue","value":"Cursor corresponding to the last possible item.","block":true},"name":{"kind":"Name","value":"endCursor"},"arguments":[],"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"String"}}},"directives":[]},{"kind":"FieldDefinition","description":{"kind":"StringValue","value":"Total number of items (products or collections), not pages.","block":true},"name":{"kind":"Name","value":"totalCount"},"arguments":[],"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"Int"}}},"directives":[]}]}],"loc":{"start":0,"end":798}};
    doc$c.loc.source = {"body":"\"\"\"\nWhenever you make a query that allows for pagination, such as `allProducts` or `allCollections`, you can check `StorePageInfo` to learn more about the complete set of items and use it to paginate your queries.\n\"\"\"\ntype StorePageInfo {\n  \"\"\"\n  Indicates whether there is at least one more page with items after the ones returned in the current query.\n  \"\"\"\n  hasNextPage: Boolean!\n  \"\"\"\n  Indicates whether there is at least one more page with items before the ones returned in the current query.\n  \"\"\"\n  hasPreviousPage: Boolean!\n  \"\"\"\n  Cursor corresponding to the first possible item.\n  \"\"\"\n  startCursor: String!\n  \"\"\"\n  Cursor corresponding to the last possible item.\n  \"\"\"\n  endCursor: String!\n  \"\"\"\n  Total number of items (products or collections), not pages.\n  \"\"\"\n  totalCount: Int!\n}\n","name":"GraphQL request","locationOffset":{"line":1,"column":1}};

var doc$d = {"kind":"Document","definitions":[{"kind":"ObjectTypeDefinition","description":{"kind":"StringValue","value":"Product information. Products are variants within product groups, equivalent to VTEX [SKUs](https://help.vtex.com/en/tutorial/what-is-an-sku--1K75s4RXAQyOuGUYKMM68u#). For example, you may have a **Shirt** product group with associated products such as **Blue shirt size L**, **Green shirt size XL** and so on.","block":true},"name":{"kind":"Name","value":"StoreProduct"},"interfaces":[],"directives":[],"fields":[{"kind":"FieldDefinition","description":{"kind":"StringValue","value":"Meta tag data.","block":true},"name":{"kind":"Name","value":"seo"},"arguments":[],"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"StoreSeo"}}},"directives":[]},{"kind":"FieldDefinition","description":{"kind":"StringValue","value":"List of items consisting of chain linked web pages, ending with the current page.","block":true},"name":{"kind":"Name","value":"breadcrumbList"},"arguments":[],"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"StoreBreadcrumbList"}}},"directives":[]},{"kind":"FieldDefinition","description":{"kind":"StringValue","value":"Corresponding collection URL slug, with which to retrieve this entity.","block":true},"name":{"kind":"Name","value":"slug"},"arguments":[],"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"String"}}},"directives":[]},{"kind":"FieldDefinition","description":{"kind":"StringValue","value":"Product name.","block":true},"name":{"kind":"Name","value":"name"},"arguments":[],"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"String"}}},"directives":[]},{"kind":"FieldDefinition","description":{"kind":"StringValue","value":"Product ID, such as [ISBN](https://www.isbn-international.org/content/what-isbn) or similar global IDs.","block":true},"name":{"kind":"Name","value":"productID"},"arguments":[],"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"String"}}},"directives":[]},{"kind":"FieldDefinition","description":{"kind":"StringValue","value":"Product brand.","block":true},"name":{"kind":"Name","value":"brand"},"arguments":[],"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"StoreBrand"}}},"directives":[]},{"kind":"FieldDefinition","description":{"kind":"StringValue","value":"Product description.","block":true},"name":{"kind":"Name","value":"description"},"arguments":[],"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"String"}}},"directives":[]},{"kind":"FieldDefinition","description":{"kind":"StringValue","value":"Array of images.","block":true},"name":{"kind":"Name","value":"image"},"arguments":[],"type":{"kind":"NonNullType","type":{"kind":"ListType","type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"StoreImage"}}}}},"directives":[]},{"kind":"FieldDefinition","description":{"kind":"StringValue","value":"Aggregate offer information.","block":true},"name":{"kind":"Name","value":"offers"},"arguments":[],"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"StoreAggregateOffer"}}},"directives":[]},{"kind":"FieldDefinition","description":{"kind":"StringValue","value":"Stock Keeping Unit. Merchant-specific ID for the product.","block":true},"name":{"kind":"Name","value":"sku"},"arguments":[],"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"String"}}},"directives":[]},{"kind":"FieldDefinition","description":{"kind":"StringValue","value":"Global Trade Item Number.","block":true},"name":{"kind":"Name","value":"gtin"},"arguments":[],"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"String"}}},"directives":[]},{"kind":"FieldDefinition","description":{"kind":"StringValue","value":"Array with review information.","block":true},"name":{"kind":"Name","value":"review"},"arguments":[],"type":{"kind":"NonNullType","type":{"kind":"ListType","type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"StoreReview"}}}}},"directives":[]},{"kind":"FieldDefinition","description":{"kind":"StringValue","value":"Aggregate ratings data.","block":true},"name":{"kind":"Name","value":"aggregateRating"},"arguments":[],"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"StoreAggregateRating"}}},"directives":[]},{"kind":"FieldDefinition","description":{"kind":"StringValue","value":"Indicates product group related to this product.","block":true},"name":{"kind":"Name","value":"isVariantOf"},"arguments":[],"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"StoreProductGroup"}}},"directives":[]},{"kind":"FieldDefinition","description":{"kind":"StringValue","value":"Array of additional properties.","block":true},"name":{"kind":"Name","value":"additionalProperty"},"arguments":[],"type":{"kind":"NonNullType","type":{"kind":"ListType","type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"StorePropertyValue"}}}}},"directives":[]}]},{"kind":"InputObjectTypeDefinition","description":{"kind":"StringValue","value":"Product input. Products are variants within product groups, equivalent to VTEX [SKUs](https://help.vtex.com/en/tutorial/what-is-an-sku--1K75s4RXAQyOuGUYKMM68u#). For example, you may have a **Shirt** product group with associated products such as **Blue shirt size L**, **Green shirt size XL** and so on.","block":true},"name":{"kind":"Name","value":"IStoreProduct"},"directives":[],"fields":[{"kind":"InputValueDefinition","description":{"kind":"StringValue","value":"Stock Keeping Unit. Merchant-specific ID for the product.","block":true},"name":{"kind":"Name","value":"sku"},"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"String"}}},"directives":[]},{"kind":"InputValueDefinition","description":{"kind":"StringValue","value":"Product name.","block":true},"name":{"kind":"Name","value":"name"},"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"String"}}},"directives":[]},{"kind":"InputValueDefinition","description":{"kind":"StringValue","value":"Array of product images.","block":true},"name":{"kind":"Name","value":"image"},"type":{"kind":"NonNullType","type":{"kind":"ListType","type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"IStoreImage"}}}}},"directives":[]},{"kind":"InputValueDefinition","description":{"kind":"StringValue","value":"Custom Product Additional Properties.","block":true},"name":{"kind":"Name","value":"additionalProperty"},"type":{"kind":"ListType","type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"IStorePropertyValue"}}}},"directives":[]}]}],"loc":{"start":0,"end":2154}};
    doc$d.loc.source = {"body":"\"\"\"\nProduct information. Products are variants within product groups, equivalent to VTEX [SKUs](https://help.vtex.com/en/tutorial/what-is-an-sku--1K75s4RXAQyOuGUYKMM68u#). For example, you may have a **Shirt** product group with associated products such as **Blue shirt size L**, **Green shirt size XL** and so on.\n\"\"\"\ntype StoreProduct {\n  \"\"\"\n  Meta tag data.\n  \"\"\"\n  seo: StoreSeo!\n  \"\"\"\n  List of items consisting of chain linked web pages, ending with the current page.\n  \"\"\"\n  breadcrumbList: StoreBreadcrumbList!\n  \"\"\"\n  Corresponding collection URL slug, with which to retrieve this entity.\n  \"\"\"\n  slug: String!\n  \"\"\"\n  Product name.\n  \"\"\"\n  name: String!\n  \"\"\"\n  Product ID, such as [ISBN](https://www.isbn-international.org/content/what-isbn) or similar global IDs.\n  \"\"\"\n  productID: String!\n  \"\"\"\n  Product brand.\n  \"\"\"\n  brand: StoreBrand!\n  \"\"\"\n  Product description.\n  \"\"\"\n  description: String!\n  \"\"\"\n  Array of images.\n  \"\"\"\n  image: [StoreImage!]!\n  \"\"\"\n  Aggregate offer information.\n  \"\"\"\n  offers: StoreAggregateOffer!\n  \"\"\"\n  Stock Keeping Unit. Merchant-specific ID for the product.\n  \"\"\"\n  sku: String!\n  \"\"\"\n  Global Trade Item Number.\n  \"\"\"\n  gtin: String!\n  \"\"\"\n  Array with review information.\n  \"\"\"\n  review: [StoreReview!]!\n  \"\"\"\n  Aggregate ratings data.\n  \"\"\"\n  aggregateRating: StoreAggregateRating!\n  \"\"\"\n  Indicates product group related to this product.\n  \"\"\"\n  isVariantOf: StoreProductGroup!\n  \"\"\"\n  Array of additional properties.\n  \"\"\"\n  additionalProperty: [StorePropertyValue!]!\n}\n\n\"\"\"\nProduct input. Products are variants within product groups, equivalent to VTEX [SKUs](https://help.vtex.com/en/tutorial/what-is-an-sku--1K75s4RXAQyOuGUYKMM68u#). For example, you may have a **Shirt** product group with associated products such as **Blue shirt size L**, **Green shirt size XL** and so on.\n\"\"\"\ninput IStoreProduct {\n  \"\"\"\n  Stock Keeping Unit. Merchant-specific ID for the product.\n  \"\"\"\n  sku: String!\n  \"\"\"\n  Product name.\n  \"\"\"\n  name: String!\n  \"\"\"\n  Array of product images.\n  \"\"\"\n  image: [IStoreImage!]!\n  \"\"\"\n  Custom Product Additional Properties.\n  \"\"\"\n  additionalProperty: [IStorePropertyValue!]\n}\n","name":"GraphQL request","locationOffset":{"line":1,"column":1}};

var doc$e = {"kind":"Document","definitions":[{"kind":"ObjectTypeDefinition","description":{"kind":"StringValue","value":"Product group information. Product groups are catalog entities that may contain variants. They are equivalent to VTEX [Products](https://help.vtex.com/en/tutorial/what-is-a-product--2zrB2gFCHyQokCKKE8kuAw#), whereas each variant is equivalent to a VTEX [SKU](https://help.vtex.com/en/tutorial/what-is-an-sku--1K75s4RXAQyOuGUYKMM68u#). For example, you may have a **Shirt** product group with associated products such as **Blue shirt size L**, **Green shirt size XL** and so on.","block":true},"name":{"kind":"Name","value":"StoreProductGroup"},"interfaces":[],"directives":[],"fields":[{"kind":"FieldDefinition","description":{"kind":"StringValue","value":"Array of variants related to product group. Variants are equivalent to VTEX [SKUs](https://help.vtex.com/en/tutorial/what-is-an-sku--1K75s4RXAQyOuGUYKMM68u#).","block":true},"name":{"kind":"Name","value":"hasVariant"},"arguments":[],"type":{"kind":"NonNullType","type":{"kind":"ListType","type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"StoreProduct"}}}}},"directives":[]},{"kind":"FieldDefinition","description":{"kind":"StringValue","value":"Product group ID.","block":true},"name":{"kind":"Name","value":"productGroupID"},"arguments":[],"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"String"}}},"directives":[]},{"kind":"FieldDefinition","description":{"kind":"StringValue","value":"Product group name.","block":true},"name":{"kind":"Name","value":"name"},"arguments":[],"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"String"}}},"directives":[]},{"kind":"FieldDefinition","description":{"kind":"StringValue","value":"Array of additional properties.","block":true},"name":{"kind":"Name","value":"additionalProperty"},"arguments":[],"type":{"kind":"NonNullType","type":{"kind":"ListType","type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"StorePropertyValue"}}}}},"directives":[]}]}],"loc":{"start":0,"end":916}};
    doc$e.loc.source = {"body":"\"\"\"\nProduct group information. Product groups are catalog entities that may contain variants. They are equivalent to VTEX [Products](https://help.vtex.com/en/tutorial/what-is-a-product--2zrB2gFCHyQokCKKE8kuAw#), whereas each variant is equivalent to a VTEX [SKU](https://help.vtex.com/en/tutorial/what-is-an-sku--1K75s4RXAQyOuGUYKMM68u#). For example, you may have a **Shirt** product group with associated products such as **Blue shirt size L**, **Green shirt size XL** and so on.\n\"\"\"\ntype StoreProductGroup {\n  \"\"\"\n  Array of variants related to product group. Variants are equivalent to VTEX [SKUs](https://help.vtex.com/en/tutorial/what-is-an-sku--1K75s4RXAQyOuGUYKMM68u#).\n  \"\"\"\n  hasVariant: [StoreProduct!]!\n  \"\"\"\n  Product group ID.\n  \"\"\"\n  productGroupID: String!\n  \"\"\"\n  Product group name.\n  \"\"\"\n  name: String!\n  \"\"\"\n  Array of additional properties.\n  \"\"\"\n  additionalProperty: [StorePropertyValue!]!\n}\n","name":"GraphQL request","locationOffset":{"line":1,"column":1}};

var doc$f = {"kind":"Document","definitions":[{"kind":"ObjectTypeDefinition","description":{"kind":"StringValue","value":"Each product edge contains a `node`, with product information, and a `cursor`, that can be used as a reference for pagination.","block":true},"name":{"kind":"Name","value":"StoreProductEdge"},"interfaces":[],"directives":[],"fields":[{"kind":"FieldDefinition","description":{"kind":"StringValue","value":"Each product node contains the information of a product returned by the query.","block":true},"name":{"kind":"Name","value":"node"},"arguments":[],"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"StoreProduct"}}},"directives":[]},{"kind":"FieldDefinition","description":{"kind":"StringValue","value":"Product cursor. Used as pagination reference.","block":true},"name":{"kind":"Name","value":"cursor"},"arguments":[],"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"String"}}},"directives":[]}]},{"kind":"ObjectTypeDefinition","description":{"kind":"StringValue","value":"Product connections, including pagination information and products returned by the query.","block":true},"name":{"kind":"Name","value":"StoreProductConnection"},"interfaces":[],"directives":[],"fields":[{"kind":"FieldDefinition","description":{"kind":"StringValue","value":"Product pagination information.","block":true},"name":{"kind":"Name","value":"pageInfo"},"arguments":[],"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"StorePageInfo"}}},"directives":[]},{"kind":"FieldDefinition","description":{"kind":"StringValue","value":"Array with product connection edges, each containing a product and a corresponding cursor.","block":true},"name":{"kind":"Name","value":"edges"},"arguments":[],"type":{"kind":"NonNullType","type":{"kind":"ListType","type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"StoreProductEdge"}}}}},"directives":[]}]},{"kind":"ObjectTypeDefinition","description":{"kind":"StringValue","value":"Each collection edge contains a `node`, with product collection information, and a `cursor`, that can be used as a reference for pagination.","block":true},"name":{"kind":"Name","value":"StoreCollectionEdge"},"interfaces":[],"directives":[],"fields":[{"kind":"FieldDefinition","description":{"kind":"StringValue","value":"Each collection node contains the information of a product collection returned by the query.","block":true},"name":{"kind":"Name","value":"node"},"arguments":[],"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"StoreCollection"}}},"directives":[]},{"kind":"FieldDefinition","description":{"kind":"StringValue","value":"Collection cursor. Used as pagination reference.","block":true},"name":{"kind":"Name","value":"cursor"},"arguments":[],"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"String"}}},"directives":[]}]},{"kind":"ObjectTypeDefinition","description":{"kind":"StringValue","value":"Collection connections, including pagination information and collections returned by the query.","block":true},"name":{"kind":"Name","value":"StoreCollectionConnection"},"interfaces":[],"directives":[],"fields":[{"kind":"FieldDefinition","description":{"kind":"StringValue","value":"Collection pagination information.","block":true},"name":{"kind":"Name","value":"pageInfo"},"arguments":[],"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"StorePageInfo"}}},"directives":[]},{"kind":"FieldDefinition","description":{"kind":"StringValue","value":"Array with collection connection page edges, each containing a collection and a corresponding cursor..","block":true},"name":{"kind":"Name","value":"edges"},"arguments":[],"type":{"kind":"NonNullType","type":{"kind":"ListType","type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"StoreCollectionEdge"}}}}},"directives":[]}]},{"kind":"EnumTypeDefinition","description":{"kind":"StringValue","value":"Product search results sorting options.","block":true},"name":{"kind":"Name","value":"StoreSort"},"directives":[],"values":[{"kind":"EnumValueDefinition","description":{"kind":"StringValue","value":"Sort by price, from highest to lowest.","block":true},"name":{"kind":"Name","value":"price_desc"},"directives":[]},{"kind":"EnumValueDefinition","description":{"kind":"StringValue","value":"Sort by price, from lowest to highest.","block":true},"name":{"kind":"Name","value":"price_asc"},"directives":[]},{"kind":"EnumValueDefinition","description":{"kind":"StringValue","value":"Sort by orders, from highest to lowest.","block":true},"name":{"kind":"Name","value":"orders_desc"},"directives":[]},{"kind":"EnumValueDefinition","description":{"kind":"StringValue","value":"Sort by name, in reverse alphabetical order.","block":true},"name":{"kind":"Name","value":"name_desc"},"directives":[]},{"kind":"EnumValueDefinition","description":{"kind":"StringValue","value":"Sort by name, in alphabetical order.","block":true},"name":{"kind":"Name","value":"name_asc"},"directives":[]},{"kind":"EnumValueDefinition","description":{"kind":"StringValue","value":"Sort by release date, from  highest to lowest.","block":true},"name":{"kind":"Name","value":"release_desc"},"directives":[]},{"kind":"EnumValueDefinition","description":{"kind":"StringValue","value":"Sort by discount value, from highest to lowest.","block":true},"name":{"kind":"Name","value":"discount_desc"},"directives":[]},{"kind":"EnumValueDefinition","description":{"kind":"StringValue","value":"Sort by product score, from highest to lowest.","block":true},"name":{"kind":"Name","value":"score_desc"},"directives":[]}]},{"kind":"InputObjectTypeDefinition","description":{"kind":"StringValue","value":"Selected search facet input.","block":true},"name":{"kind":"Name","value":"IStoreSelectedFacet"},"directives":[],"fields":[{"kind":"InputValueDefinition","description":{"kind":"StringValue","value":"Selected search facet key.","block":true},"name":{"kind":"Name","value":"key"},"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"String"}}},"directives":[]},{"kind":"InputValueDefinition","description":{"kind":"StringValue","value":"Selected search facet value.","block":true},"name":{"kind":"Name","value":"value"},"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"String"}}},"directives":[]}]},{"kind":"EnumTypeDefinition","description":{"kind":"StringValue","value":"Search facet type.","block":true},"name":{"kind":"Name","value":"StoreFacetType"},"directives":[],"values":[{"kind":"EnumValueDefinition","description":{"kind":"StringValue","value":"Indicates boolean search facet.","block":true},"name":{"kind":"Name","value":"BOOLEAN"},"directives":[]},{"kind":"EnumValueDefinition","description":{"kind":"StringValue","value":"Indicates range type search facet.","block":true},"name":{"kind":"Name","value":"RANGE"},"directives":[]}]},{"kind":"ObjectTypeDefinition","description":{"kind":"StringValue","value":"Suggestion term.","block":true},"name":{"kind":"Name","value":"StoreSuggestionTerm"},"interfaces":[],"directives":[],"fields":[{"kind":"FieldDefinition","description":{"kind":"StringValue","value":"The term.","block":true},"name":{"kind":"Name","value":"value"},"arguments":[],"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"String"}}},"directives":[]},{"kind":"FieldDefinition","description":{"kind":"StringValue","value":"Its occurrences count.","block":true},"name":{"kind":"Name","value":"count"},"arguments":[],"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"Int"}}},"directives":[]}]},{"kind":"ObjectTypeDefinition","description":{"kind":"StringValue","value":"Suggestions information.","block":true},"name":{"kind":"Name","value":"StoreSuggestions"},"interfaces":[],"directives":[],"fields":[{"kind":"FieldDefinition","description":{"kind":"StringValue","value":"Array with suggestion terms.","block":true},"name":{"kind":"Name","value":"terms"},"arguments":[],"type":{"kind":"NonNullType","type":{"kind":"ListType","type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"StoreSuggestionTerm"}}}}},"directives":[]},{"kind":"FieldDefinition","description":{"kind":"StringValue","value":"Array with suggestion products' information.","block":true},"name":{"kind":"Name","value":"products"},"arguments":[],"type":{"kind":"NonNullType","type":{"kind":"ListType","type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"StoreProduct"}}}}},"directives":[]}]},{"kind":"ObjectTypeDefinition","description":{"kind":"StringValue","value":"Search result.","block":true},"name":{"kind":"Name","value":"StoreSearchResult"},"interfaces":[],"directives":[],"fields":[{"kind":"FieldDefinition","description":{"kind":"StringValue","value":"Search result products.","block":true},"name":{"kind":"Name","value":"products"},"arguments":[],"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"StoreProductConnection"}}},"directives":[]},{"kind":"FieldDefinition","description":{"kind":"StringValue","value":"Array of search result facets.","block":true},"name":{"kind":"Name","value":"facets"},"arguments":[],"type":{"kind":"NonNullType","type":{"kind":"ListType","type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"StoreFacet"}}}}},"directives":[]},{"kind":"FieldDefinition","description":{"kind":"StringValue","value":"Search result suggestions.","block":true},"name":{"kind":"Name","value":"suggestions"},"arguments":[],"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"StoreSuggestions"}}},"directives":[]}]},{"kind":"ObjectTypeDefinition","name":{"kind":"Name","value":"Query"},"interfaces":[],"directives":[],"fields":[{"kind":"FieldDefinition","description":{"kind":"StringValue","value":"Returns the details of a product based on the specified locator.","block":true},"name":{"kind":"Name","value":"product"},"arguments":[{"kind":"InputValueDefinition","description":{"kind":"StringValue","value":"An array of selected search facets.","block":true},"name":{"kind":"Name","value":"locator"},"type":{"kind":"NonNullType","type":{"kind":"ListType","type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"IStoreSelectedFacet"}}}}},"directives":[]}],"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"StoreProduct"}}},"directives":[]},{"kind":"FieldDefinition","description":{"kind":"StringValue","value":"Returns the details of a collection based on the collection slug.","block":true},"name":{"kind":"Name","value":"collection"},"arguments":[{"kind":"InputValueDefinition","description":{"kind":"StringValue","value":"Collection slug.","block":true},"name":{"kind":"Name","value":"slug"},"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"String"}}},"directives":[]}],"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"StoreCollection"}}},"directives":[]},{"kind":"FieldDefinition","description":{"kind":"StringValue","value":"Returns the result of a product, facet, or suggestion search.","block":true},"name":{"kind":"Name","value":"search"},"arguments":[{"kind":"InputValueDefinition","description":{"kind":"StringValue","value":"Search pagination argument, indicating how many results should be returned from the complete result list.","block":true},"name":{"kind":"Name","value":"first"},"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"Int"}}},"directives":[]},{"kind":"InputValueDefinition","description":{"kind":"StringValue","value":"Search pagination argument, indicating the cursor corresponding with the item after which the results should be fetched.","block":true},"name":{"kind":"Name","value":"after"},"type":{"kind":"NamedType","name":{"kind":"Name","value":"String"}},"directives":[]},{"kind":"InputValueDefinition","description":{"kind":"StringValue","value":"Search results sorting mode.","block":true},"name":{"kind":"Name","value":"sort"},"type":{"kind":"NamedType","name":{"kind":"Name","value":"StoreSort"}},"defaultValue":{"kind":"EnumValue","value":"score_desc"},"directives":[]},{"kind":"InputValueDefinition","description":{"kind":"StringValue","value":"Search term.","block":true},"name":{"kind":"Name","value":"term"},"type":{"kind":"NamedType","name":{"kind":"Name","value":"String"}},"defaultValue":{"kind":"StringValue","value":"","block":false},"directives":[]},{"kind":"InputValueDefinition","description":{"kind":"StringValue","value":"Array of selected search facets.","block":true},"name":{"kind":"Name","value":"selectedFacets"},"type":{"kind":"ListType","type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"IStoreSelectedFacet"}}}},"directives":[]}],"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"StoreSearchResult"}}},"directives":[]},{"kind":"FieldDefinition","description":{"kind":"StringValue","value":"Returns information about all products.","block":true},"name":{"kind":"Name","value":"allProducts"},"arguments":[{"kind":"InputValueDefinition","description":{"kind":"StringValue","value":"Product pagination argument, indicating how many items should be returned from the complete result list.","block":true},"name":{"kind":"Name","value":"first"},"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"Int"}}},"directives":[]},{"kind":"InputValueDefinition","description":{"kind":"StringValue","value":"Product pagination argument, indicating the cursor corresponding with the item after which the items should be fetched.","block":true},"name":{"kind":"Name","value":"after"},"type":{"kind":"NamedType","name":{"kind":"Name","value":"String"}},"directives":[]}],"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"StoreProductConnection"}}},"directives":[]},{"kind":"FieldDefinition","description":{"kind":"StringValue","value":"Returns information about all collections.","block":true},"name":{"kind":"Name","value":"allCollections"},"arguments":[{"kind":"InputValueDefinition","description":{"kind":"StringValue","value":"Collection pagination argument, indicating how many items should be returned from the complete result list.","block":true},"name":{"kind":"Name","value":"first"},"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"Int"}}},"directives":[]},{"kind":"InputValueDefinition","description":{"kind":"StringValue","value":"Collection pagination argument, indicating the cursor corresponding with the item after which the items should be fetched.","block":true},"name":{"kind":"Name","value":"after"},"type":{"kind":"NamedType","name":{"kind":"Name","value":"String"}},"directives":[]}],"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"StoreCollectionConnection"}}},"directives":[]}]}],"loc":{"start":0,"end":4916}};
    doc$f.loc.source = {"body":"\"\"\"\nEach product edge contains a `node`, with product information, and a `cursor`, that can be used as a reference for pagination.\n\"\"\"\ntype StoreProductEdge {\n  \"\"\"\n  Each product node contains the information of a product returned by the query.\n  \"\"\"\n  node: StoreProduct!\n  \"\"\"\n  Product cursor. Used as pagination reference.\n  \"\"\"\n  cursor: String!\n}\n\n\"\"\"\nProduct connections, including pagination information and products returned by the query.\n\"\"\"\ntype StoreProductConnection {\n  \"\"\"\n  Product pagination information.\n  \"\"\"\n  pageInfo: StorePageInfo!\n  \"\"\"\n  Array with product connection edges, each containing a product and a corresponding cursor.\n  \"\"\"\n  edges: [StoreProductEdge!]!\n}\n\n\"\"\"\nEach collection edge contains a `node`, with product collection information, and a `cursor`, that can be used as a reference for pagination.\n\"\"\"\ntype StoreCollectionEdge {\n  \"\"\"\n  Each collection node contains the information of a product collection returned by the query.\n  \"\"\"\n  node: StoreCollection!\n  \"\"\"\n  Collection cursor. Used as pagination reference.\n  \"\"\"\n  cursor: String!\n}\n\n\"\"\"\nCollection connections, including pagination information and collections returned by the query.\n\"\"\"\ntype StoreCollectionConnection {\n  \"\"\"\n  Collection pagination information.\n  \"\"\"\n  pageInfo: StorePageInfo!\n  \"\"\"\n  Array with collection connection page edges, each containing a collection and a corresponding cursor..\n  \"\"\"\n  edges: [StoreCollectionEdge!]!\n}\n\n\"\"\"\nProduct search results sorting options.\n\"\"\"\nenum StoreSort {\n  \"\"\"\n  Sort by price, from highest to lowest.\n  \"\"\"\n  price_desc\n  \"\"\"\n  Sort by price, from lowest to highest.\n  \"\"\"\n  price_asc\n  \"\"\"\n  Sort by orders, from highest to lowest.\n  \"\"\"\n  orders_desc\n  \"\"\"\n  Sort by name, in reverse alphabetical order.\n  \"\"\"\n  name_desc\n  \"\"\"\n  Sort by name, in alphabetical order.\n  \"\"\"\n  name_asc\n  \"\"\"\n  Sort by release date, from  highest to lowest.\n  \"\"\"\n  release_desc\n  \"\"\"\n  Sort by discount value, from highest to lowest.\n  \"\"\"\n  discount_desc\n  \"\"\"\n  Sort by product score, from highest to lowest.\n  \"\"\"\n  score_desc\n}\n\n\"\"\"\nSelected search facet input.\n\"\"\"\ninput IStoreSelectedFacet {\n  \"\"\"\n  Selected search facet key.\n  \"\"\"\n  key: String!\n  \"\"\"\n  Selected search facet value.\n  \"\"\"\n  value: String!\n}\n\n\"\"\"\nSearch facet type.\n\"\"\"\nenum StoreFacetType {\n  \"\"\"\n  Indicates boolean search facet.\n  \"\"\"\n  BOOLEAN\n  \"\"\"\n  Indicates range type search facet.\n  \"\"\"\n  RANGE\n}\n\n\"\"\"\nSuggestion term.\n\"\"\"\ntype StoreSuggestionTerm {\n  \"\"\"\n  The term.\n  \"\"\"\n  value: String!\n  \"\"\"\n  Its occurrences count.\n  \"\"\"\n  count: Int!\n}\n\n\"\"\"\nSuggestions information.\n\"\"\"\ntype StoreSuggestions {\n  \"\"\"\n  Array with suggestion terms.\n  \"\"\"\n  terms: [StoreSuggestionTerm!]!\n  \"\"\"\n  Array with suggestion products' information.\n  \"\"\"\n  products: [StoreProduct!]!\n}\n\n\"\"\"\nSearch result.\n\"\"\"\ntype StoreSearchResult {\n  \"\"\"\n  Search result products.\n  \"\"\"\n  products: StoreProductConnection!\n  \"\"\"\n  Array of search result facets.\n  \"\"\"\n  facets: [StoreFacet!]!\n  \"\"\"\n  Search result suggestions.\n  \"\"\"\n  suggestions: StoreSuggestions!\n}\n\ntype Query {\n  \"\"\"\n  Returns the details of a product based on the specified locator.\n  \"\"\"\n  product(\n    \"\"\"\n    An array of selected search facets.\n    \"\"\"\n    locator: [IStoreSelectedFacet!]!\n  ): StoreProduct!\n\n  \"\"\"\n  Returns the details of a collection based on the collection slug.\n  \"\"\"\n  collection(\n    \"\"\"\n    Collection slug.\n    \"\"\"\n    slug: String!\n  ): StoreCollection!\n\n  \"\"\"\n  Returns the result of a product, facet, or suggestion search.\n  \"\"\"\n  search(\n    \"\"\"\n    Search pagination argument, indicating how many results should be returned from the complete result list.\n    \"\"\"\n    first: Int!\n    \"\"\"\n    Search pagination argument, indicating the cursor corresponding with the item after which the results should be fetched.\n    \"\"\"\n    after: String\n    \"\"\"\n    Search results sorting mode.\n    \"\"\"\n    sort: StoreSort = score_desc\n    \"\"\"\n    Search term.\n    \"\"\"\n    term: String = \"\"\n    \"\"\"\n    Array of selected search facets.\n    \"\"\"\n    selectedFacets: [IStoreSelectedFacet!]\n  ): StoreSearchResult!\n\n  \"\"\"\n  Returns information about all products.\n  \"\"\"\n  allProducts(\n    \"\"\"\n    Product pagination argument, indicating how many items should be returned from the complete result list.\n    \"\"\"\n    first: Int!,\n    \"\"\"\n    Product pagination argument, indicating the cursor corresponding with the item after which the items should be fetched.\n    \"\"\"\n    after: String\n  ): StoreProductConnection!\n\n  \"\"\"\n  Returns information about all collections.\n  \"\"\"\n  allCollections(\n    \"\"\"\n    Collection pagination argument, indicating how many items should be returned from the complete result list.\n    \"\"\"\n    first: Int!,\n    \"\"\"\n    Collection pagination argument, indicating the cursor corresponding with the item after which the items should be fetched.\n    \"\"\"\n    after: String\n  ): StoreCollectionConnection!\n}\n","name":"GraphQL request","locationOffset":{"line":1,"column":1}};

var doc$g = {"kind":"Document","definitions":[{"kind":"ObjectTypeDefinition","description":{"kind":"StringValue","value":"Information of a given review rating.","block":true},"name":{"kind":"Name","value":"StoreReviewRating"},"interfaces":[],"directives":[],"fields":[{"kind":"FieldDefinition","description":{"kind":"StringValue","value":"Rating value.","block":true},"name":{"kind":"Name","value":"ratingValue"},"arguments":[],"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"Float"}}},"directives":[]},{"kind":"FieldDefinition","description":{"kind":"StringValue","value":"Best rating value.","block":true},"name":{"kind":"Name","value":"bestRating"},"arguments":[],"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"Float"}}},"directives":[]}]},{"kind":"ObjectTypeDefinition","description":{"kind":"StringValue","value":"Information of a given review.","block":true},"name":{"kind":"Name","value":"StoreReview"},"interfaces":[],"directives":[],"fields":[{"kind":"FieldDefinition","description":{"kind":"StringValue","value":"Review rating information.","block":true},"name":{"kind":"Name","value":"reviewRating"},"arguments":[],"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"StoreReviewRating"}}},"directives":[]},{"kind":"FieldDefinition","description":{"kind":"StringValue","value":"Review author.","block":true},"name":{"kind":"Name","value":"author"},"arguments":[],"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"StoreAuthor"}}},"directives":[]}]}],"loc":{"start":0,"end":366}};
    doc$g.loc.source = {"body":"\"\"\"\nInformation of a given review rating.\n\"\"\"\ntype StoreReviewRating {\n  \"\"\"\n  Rating value.\n  \"\"\"\n  ratingValue: Float!\n  \"\"\"\n  Best rating value.\n  \"\"\"\n  bestRating: Float!\n}\n\n\"\"\"\nInformation of a given review.\n\"\"\"\ntype StoreReview {\n  \"\"\"\n  Review rating information.\n  \"\"\"\n  reviewRating: StoreReviewRating!\n  \"\"\"\n  Review author.\n  \"\"\"\n  author: StoreAuthor!\n}\n","name":"GraphQL request","locationOffset":{"line":1,"column":1}};

var doc$h = {"kind":"Document","definitions":[{"kind":"ObjectTypeDefinition","description":{"kind":"StringValue","value":"Search Engine Optimization (SEO) tags data.","block":true},"name":{"kind":"Name","value":"StoreSeo"},"interfaces":[],"directives":[],"fields":[{"kind":"FieldDefinition","description":{"kind":"StringValue","value":"Title tag.","block":true},"name":{"kind":"Name","value":"title"},"arguments":[],"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"String"}}},"directives":[]},{"kind":"FieldDefinition","description":{"kind":"StringValue","value":"Title template tag.","block":true},"name":{"kind":"Name","value":"titleTemplate"},"arguments":[],"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"String"}}},"directives":[]},{"kind":"FieldDefinition","description":{"kind":"StringValue","value":"Description tag.","block":true},"name":{"kind":"Name","value":"description"},"arguments":[],"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"String"}}},"directives":[]},{"kind":"FieldDefinition","description":{"kind":"StringValue","value":"Canonical tag.","block":true},"name":{"kind":"Name","value":"canonical"},"arguments":[],"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"String"}}},"directives":[]}]}],"loc":{"start":0,"end":275}};
    doc$h.loc.source = {"body":"\"\"\"\nSearch Engine Optimization (SEO) tags data.\n\"\"\"\ntype StoreSeo {\n  \"\"\"\n  Title tag.\n  \"\"\"\n  title: String!\n  \"\"\"\n  Title template tag.\n  \"\"\"\n  titleTemplate: String!\n  \"\"\"\n  Description tag.\n  \"\"\"\n  description: String!\n  \"\"\"\n  Canonical tag.\n  \"\"\"\n  canonical: String!\n}\n","name":"GraphQL request","locationOffset":{"line":1,"column":1}};

var doc$i = {"kind":"Document","definitions":[{"kind":"ObjectTypeDefinition","description":{"kind":"StringValue","value":"Shopping cart message.","block":true},"name":{"kind":"Name","value":"StoreCartMessage"},"interfaces":[],"directives":[],"fields":[{"kind":"FieldDefinition","description":{"kind":"StringValue","value":"Shopping cart message text.","block":true},"name":{"kind":"Name","value":"text"},"arguments":[],"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"String"}}},"directives":[]},{"kind":"FieldDefinition","description":{"kind":"StringValue","value":"Shopping cart message status, which can be `INFO`, `WARNING` or `ERROR`.","block":true},"name":{"kind":"Name","value":"status"},"arguments":[],"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"StoreStatus"}}},"directives":[]}]},{"kind":"ObjectTypeDefinition","description":{"kind":"StringValue","value":"Shopping cart information.","block":true},"name":{"kind":"Name","value":"StoreCart"},"interfaces":[],"directives":[],"fields":[{"kind":"FieldDefinition","description":{"kind":"StringValue","value":"Order information, including `orderNumber` and `acceptedOffer`.","block":true},"name":{"kind":"Name","value":"order"},"arguments":[],"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"StoreOrder"}}},"directives":[]},{"kind":"FieldDefinition","description":{"kind":"StringValue","value":"List of shopping cart messages.","block":true},"name":{"kind":"Name","value":"messages"},"arguments":[],"type":{"kind":"NonNullType","type":{"kind":"ListType","type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"StoreCartMessage"}}}}},"directives":[]}]},{"kind":"InputObjectTypeDefinition","description":{"kind":"StringValue","value":"Shopping cart input.","block":true},"name":{"kind":"Name","value":"IStoreCart"},"directives":[],"fields":[{"kind":"InputValueDefinition","description":{"kind":"StringValue","value":"Order information, including `orderNumber` and `acceptedOffer`.","block":true},"name":{"kind":"Name","value":"order"},"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"IStoreOrder"}}},"directives":[]}]}],"loc":{"start":0,"end":609}};
    doc$i.loc.source = {"body":"\"\"\"\nShopping cart message.\n\"\"\"\ntype StoreCartMessage {\n  \"\"\"\n  Shopping cart message text.\n  \"\"\"\n  text: String!\n  \"\"\"\n  Shopping cart message status, which can be `INFO`, `WARNING` or `ERROR`.\n  \"\"\"\n  status: StoreStatus!\n}\n\n\"\"\"\nShopping cart information.\n\"\"\"\ntype StoreCart {\n  \"\"\"\n  Order information, including `orderNumber` and `acceptedOffer`.\n  \"\"\"\n  order: StoreOrder!\n  \"\"\"\n  List of shopping cart messages.\n  \"\"\"\n  messages: [StoreCartMessage!]!\n}\n\n\"\"\"\nShopping cart input.\n\"\"\"\ninput IStoreCart {\n  \"\"\"\n  Order information, including `orderNumber` and `acceptedOffer`.\n  \"\"\"\n  order: IStoreOrder!\n}\n","name":"GraphQL request","locationOffset":{"line":1,"column":1}};

var doc$j = {"kind":"Document","definitions":[{"kind":"EnumTypeDefinition","description":{"kind":"StringValue","value":"Status used to indicate a message type. For instance, a shopping cart informative or error message.","block":true},"name":{"kind":"Name","value":"StoreStatus"},"directives":[],"values":[{"kind":"EnumValueDefinition","name":{"kind":"Name","value":"INFO"},"directives":[]},{"kind":"EnumValueDefinition","name":{"kind":"Name","value":"WARNING"},"directives":[]},{"kind":"EnumValueDefinition","name":{"kind":"Name","value":"ERROR"},"directives":[]}]}],"loc":{"start":0,"end":154}};
    doc$j.loc.source = {"body":"\"\"\"\nStatus used to indicate a message type. For instance, a shopping cart informative or error message.\n\"\"\"\nenum StoreStatus {\n  INFO\n  WARNING\n  ERROR\n}\n","name":"GraphQL request","locationOffset":{"line":1,"column":1}};

var doc$k = {"kind":"Document","definitions":[{"kind":"ObjectTypeDefinition","description":{"kind":"StringValue","value":"Properties that can be associated with products and products groups.","block":true},"name":{"kind":"Name","value":"StorePropertyValue"},"interfaces":[],"directives":[],"fields":[{"kind":"FieldDefinition","description":{"kind":"StringValue","value":"Property id. This propert changes according to the content of the object.","block":true},"name":{"kind":"Name","value":"propertyID"},"arguments":[],"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"String"}}},"directives":[]},{"kind":"FieldDefinition","description":{"kind":"StringValue","value":"Property value. May hold a string or the string representation of an object.","block":true},"name":{"kind":"Name","value":"value"},"arguments":[],"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"ObjectOrString"}}},"directives":[]},{"kind":"FieldDefinition","description":{"kind":"StringValue","value":"Property name.","block":true},"name":{"kind":"Name","value":"name"},"arguments":[],"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"String"}}},"directives":[]},{"kind":"FieldDefinition","description":{"kind":"StringValue","value":"Specifies the nature of the value","block":true},"name":{"kind":"Name","value":"valueReference"},"arguments":[],"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"String"}}},"directives":[]}]},{"kind":"InputObjectTypeDefinition","name":{"kind":"Name","value":"IStorePropertyValue"},"directives":[],"fields":[{"kind":"InputValueDefinition","description":{"kind":"StringValue","value":"Property id. This propert changes according to the content of the object.","block":true},"name":{"kind":"Name","value":"propertyID"},"type":{"kind":"NamedType","name":{"kind":"Name","value":"String"}},"directives":[]},{"kind":"InputValueDefinition","description":{"kind":"StringValue","value":"Property value. May hold a string or the string representation of an object.","block":true},"name":{"kind":"Name","value":"value"},"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"ObjectOrString"}}},"directives":[]},{"kind":"InputValueDefinition","description":{"kind":"StringValue","value":"Property name.","block":true},"name":{"kind":"Name","value":"name"},"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"String"}}},"directives":[]},{"kind":"InputValueDefinition","description":{"kind":"StringValue","value":"Specifies the nature of the value","block":true},"name":{"kind":"Name","value":"valueReference"},"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"String"}}},"directives":[]}]}],"loc":{"start":0,"end":825}};
    doc$k.loc.source = {"body":"\"\"\"\nProperties that can be associated with products and products groups.\n\"\"\"\ntype StorePropertyValue {\n  \"\"\"\n  Property id. This propert changes according to the content of the object.\n  \"\"\"\n  propertyID: String!\n  \"\"\"\n  Property value. May hold a string or the string representation of an object.\n  \"\"\"\n  value: ObjectOrString!\n  \"\"\"\n  Property name.\n  \"\"\"\n  name: String!\n  \"\"\"\n  Specifies the nature of the value\n  \"\"\"\n  valueReference: String!\n}\n\ninput IStorePropertyValue {\n  \"\"\"\n  Property id. This propert changes according to the content of the object.\n  \"\"\"\n  propertyID: String\n  \"\"\"\n  Property value. May hold a string or the string representation of an object.\n  \"\"\"\n  value: ObjectOrString!\n  \"\"\"\n  Property name.\n  \"\"\"\n  name: String!\n  \"\"\"\n  Specifies the nature of the value\n  \"\"\"\n  valueReference: String!\n}\n","name":"GraphQL request","locationOffset":{"line":1,"column":1}};

var doc$l = {"kind":"Document","definitions":[{"kind":"ObjectTypeDefinition","description":{"kind":"StringValue","value":"Client profile data.","block":true},"name":{"kind":"Name","value":"StorePerson"},"interfaces":[],"directives":[],"fields":[{"kind":"FieldDefinition","description":{"kind":"StringValue","value":"Client ID.","block":true},"name":{"kind":"Name","value":"id"},"arguments":[],"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"String"}}},"directives":[]},{"kind":"FieldDefinition","description":{"kind":"StringValue","value":"Client email.","block":true},"name":{"kind":"Name","value":"email"},"arguments":[],"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"String"}}},"directives":[]},{"kind":"FieldDefinition","description":{"kind":"StringValue","value":"Client first name.","block":true},"name":{"kind":"Name","value":"givenName"},"arguments":[],"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"String"}}},"directives":[]},{"kind":"FieldDefinition","description":{"kind":"StringValue","value":"Client last name.","block":true},"name":{"kind":"Name","value":"familyName"},"arguments":[],"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"String"}}},"directives":[]}]},{"kind":"InputObjectTypeDefinition","description":{"kind":"StringValue","value":"Client profile data.","block":true},"name":{"kind":"Name","value":"IStorePerson"},"directives":[],"fields":[{"kind":"InputValueDefinition","description":{"kind":"StringValue","value":"Client ID.","block":true},"name":{"kind":"Name","value":"id"},"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"String"}}},"directives":[]},{"kind":"InputValueDefinition","description":{"kind":"StringValue","value":"Client email.","block":true},"name":{"kind":"Name","value":"email"},"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"String"}}},"directives":[]},{"kind":"InputValueDefinition","description":{"kind":"StringValue","value":"Client first name.","block":true},"name":{"kind":"Name","value":"givenName"},"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"String"}}},"directives":[]},{"kind":"InputValueDefinition","description":{"kind":"StringValue","value":"Client last name.","block":true},"name":{"kind":"Name","value":"familyName"},"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"String"}}},"directives":[]}]}],"loc":{"start":0,"end":487}};
    doc$l.loc.source = {"body":"\"\"\"\nClient profile data.\n\"\"\"\ntype StorePerson {\n  \"\"\"\n  Client ID.\n  \"\"\"\n  id: String!\n  \"\"\"\n  Client email.\n  \"\"\"\n  email: String!\n  \"\"\"\n  Client first name.\n  \"\"\"\n  givenName: String!\n  \"\"\"\n  Client last name.\n  \"\"\"\n  familyName: String!\n}\n\n\"\"\"\nClient profile data.\n\"\"\"\ninput IStorePerson {\n  \"\"\"\n  Client ID.\n  \"\"\"\n  id: String!\n  \"\"\"\n  Client email.\n  \"\"\"\n  email: String!\n  \"\"\"\n  Client first name.\n  \"\"\"\n  givenName: String!\n  \"\"\"\n  Client last name.\n  \"\"\"\n  familyName: String!\n}\n","name":"GraphQL request","locationOffset":{"line":1,"column":1}};

var doc$m = {"kind":"Document","definitions":[{"kind":"ScalarTypeDefinition","name":{"kind":"Name","value":"ObjectOrString"},"directives":[]}],"loc":{"start":0,"end":21}};
    doc$m.loc.source = {"body":"scalar ObjectOrString","name":"GraphQL request","locationOffset":{"line":1,"column":1}};

var doc$n = {"kind":"Document","definitions":[{"kind":"ObjectTypeDefinition","description":{"kind":"StringValue","value":"Currency information.","block":true},"name":{"kind":"Name","value":"StoreCurrency"},"interfaces":[],"directives":[],"fields":[{"kind":"FieldDefinition","description":{"kind":"StringValue","value":"Currency code (e.g: USD).","block":true},"name":{"kind":"Name","value":"code"},"arguments":[],"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"String"}}},"directives":[]},{"kind":"FieldDefinition","description":{"kind":"StringValue","value":"Currency symbol (e.g: $).","block":true},"name":{"kind":"Name","value":"symbol"},"arguments":[],"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"String"}}},"directives":[]}]},{"kind":"InputObjectTypeDefinition","name":{"kind":"Name","value":"IStoreCurrency"},"directives":[],"fields":[{"kind":"InputValueDefinition","description":{"kind":"StringValue","value":"Currency code (e.g: USD).","block":true},"name":{"kind":"Name","value":"code"},"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"String"}}},"directives":[]},{"kind":"InputValueDefinition","description":{"kind":"StringValue","value":"Currency symbol (e.g: $).","block":true},"name":{"kind":"Name","value":"symbol"},"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"String"}}},"directives":[]}]},{"kind":"ObjectTypeDefinition","description":{"kind":"StringValue","value":"Session information.","block":true},"name":{"kind":"Name","value":"StoreSession"},"interfaces":[],"directives":[],"fields":[{"kind":"FieldDefinition","description":{"kind":"StringValue","value":"Session locale.","block":true},"name":{"kind":"Name","value":"locale"},"arguments":[],"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"String"}}},"directives":[]},{"kind":"FieldDefinition","description":{"kind":"StringValue","value":"Session currency.","block":true},"name":{"kind":"Name","value":"currency"},"arguments":[],"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"StoreCurrency"}}},"directives":[]},{"kind":"FieldDefinition","description":{"kind":"StringValue","value":"Session country.","block":true},"name":{"kind":"Name","value":"country"},"arguments":[],"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"String"}}},"directives":[]},{"kind":"FieldDefinition","description":{"kind":"StringValue","value":"Session channel.","block":true},"name":{"kind":"Name","value":"channel"},"arguments":[],"type":{"kind":"NamedType","name":{"kind":"Name","value":"String"}},"directives":[]},{"kind":"FieldDefinition","description":{"kind":"StringValue","value":"Session postal code.","block":true},"name":{"kind":"Name","value":"postalCode"},"arguments":[],"type":{"kind":"NamedType","name":{"kind":"Name","value":"String"}},"directives":[]},{"kind":"FieldDefinition","description":{"kind":"StringValue","value":"Session postal code.","block":true},"name":{"kind":"Name","value":"person"},"arguments":[],"type":{"kind":"NamedType","name":{"kind":"Name","value":"StorePerson"}},"directives":[]}]},{"kind":"InputObjectTypeDefinition","description":{"kind":"StringValue","value":"Session input.","block":true},"name":{"kind":"Name","value":"IStoreSession"},"directives":[],"fields":[{"kind":"InputValueDefinition","description":{"kind":"StringValue","value":"Session input locale.","block":true},"name":{"kind":"Name","value":"locale"},"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"String"}}},"directives":[]},{"kind":"InputValueDefinition","description":{"kind":"StringValue","value":"Session input currency.","block":true},"name":{"kind":"Name","value":"currency"},"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"IStoreCurrency"}}},"directives":[]},{"kind":"InputValueDefinition","description":{"kind":"StringValue","value":"Session input country.","block":true},"name":{"kind":"Name","value":"country"},"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"String"}}},"directives":[]},{"kind":"InputValueDefinition","description":{"kind":"StringValue","value":"Session input channel.","block":true},"name":{"kind":"Name","value":"channel"},"type":{"kind":"NamedType","name":{"kind":"Name","value":"String"}},"directives":[]},{"kind":"InputValueDefinition","description":{"kind":"StringValue","value":"Session input postal code.","block":true},"name":{"kind":"Name","value":"postalCode"},"type":{"kind":"NamedType","name":{"kind":"Name","value":"String"}},"directives":[]},{"kind":"InputValueDefinition","description":{"kind":"StringValue","value":"Session input postal code.","block":true},"name":{"kind":"Name","value":"person"},"type":{"kind":"NamedType","name":{"kind":"Name","value":"IStorePerson"}},"directives":[]}]}],"loc":{"start":0,"end":1083}};
    doc$n.loc.source = {"body":"\"\"\"\nCurrency information.\n\"\"\"\ntype StoreCurrency {\n  \"\"\"\n  Currency code (e.g: USD).\n  \"\"\"\n  code: String!\n  \"\"\"\n  Currency symbol (e.g: $).\n  \"\"\"\n  symbol: String!\n}\n\ninput IStoreCurrency {\n  \"\"\"\n  Currency code (e.g: USD).\n  \"\"\"\n  code: String!\n  \"\"\"\n  Currency symbol (e.g: $).\n  \"\"\"\n  symbol: String!\n}\n\n\"\"\"\nSession information.\n\"\"\"\ntype StoreSession {\n  \"\"\"\n  Session locale.\n  \"\"\"\n  locale: String!\n  \"\"\"\n  Session currency.\n  \"\"\"\n  currency: StoreCurrency!\n  \"\"\"\n  Session country.\n  \"\"\"\n  country: String!\n  \"\"\"\n  Session channel.\n  \"\"\"\n  channel: String\n  \"\"\"\n  Session postal code.\n  \"\"\"\n  postalCode: String\n  \"\"\"\n  Session postal code.\n  \"\"\"\n  person: StorePerson\n}\n\n\"\"\"\nSession input.\n\"\"\"\ninput IStoreSession {\n  \"\"\"\n  Session input locale.\n  \"\"\"\n  locale: String!\n  \"\"\"\n  Session input currency.\n  \"\"\"\n  currency: IStoreCurrency!\n  \"\"\"\n  Session input country.\n  \"\"\"\n  country: String!\n  \"\"\"\n  Session input channel.\n  \"\"\"\n  channel: String\n  \"\"\"\n  Session input postal code.\n  \"\"\"\n  postalCode: String\n  \"\"\"\n  Session input postal code.\n  \"\"\"\n  person: IStorePerson\n}\n","name":"GraphQL request","locationOffset":{"line":1,"column":1}};

const typeDefs = /*#__PURE__*/[doc$f, doc$8, doc$3, doc$4, doc$5, doc$6, doc$7, doc$c, doc$d, doc$h, doc$9, doc$1, doc$g, doc$2, doc$e, doc$b, doc, doc$a, doc$i, doc$j, doc$k, doc$l, doc$m, doc$n].map(print).join('\n');

const platforms = {
  vtex: {
    getResolvers: getResolvers,
    getContextFactory: getContextFactory
  }
};
const getTypeDefs = () => typeDefs;
const getResolvers$1 = options => platforms[options.platform].getResolvers(options);
const getContextFactory$1 = options => platforms[options.platform].getContextFactory(options);
const getSchema = async options => makeExecutableSchema({
  resolvers: getResolvers$1(options),
  typeDefs
});

export { BadRequestError, NotFoundError, getContextFactory$1 as getContextFactory, getResolvers$1 as getResolvers, getSchema, getTypeDefs, isBadRequestError, isFastStoreError, isNotFoundError };
//# sourceMappingURL=api.esm.js.map
