{"version":3,"file":"api.cjs.production.min.js","sources":["../src/platforms/vtex/clients/fetch.ts","../src/platforms/vtex/clients/commerce/index.ts","../src/platforms/vtex/clients/search/index.ts","../src/platforms/vtex/clients/sp/index.ts","../src/platforms/vtex/utils/enhanceSku.ts","../src/platforms/errors.ts","../src/platforms/vtex/loaders/collection.ts","../src/platforms/vtex/utils/productStock.ts","../src/platforms/vtex/resolvers/aggregateOffer.ts","../src/platforms/vtex/utils/slugify.ts","../src/platforms/vtex/resolvers/collection.ts","../src/platforms/vtex/utils/channel.ts","../src/platforms/vtex/utils/facets.ts","../src/platforms/vtex/utils/orderStatistics.ts","../src/platforms/vtex/resolvers/facet.ts","../src/platforms/vtex/utils/md5.ts","../src/platforms/vtex/utils/propertyValue.ts","../src/platforms/vtex/resolvers/validateCart.ts","../src/platforms/vtex/resolvers/mutation.ts","../src/platforms/vtex/resolvers/validateSession.ts","../src/platforms/vtex/resolvers/objectOrString.ts","../src/platforms/vtex/resolvers/offer.ts","../src/platforms/vtex/utils/canonical.ts","../src/platforms/vtex/resolvers/product.ts","../src/platforms/vtex/utils/enhanceCommercialOffer.ts","../src/platforms/vtex/resolvers/productGroup.ts","../src/platforms/vtex/utils/contex.ts","../src/platforms/vtex/utils/sort.ts","../src/platforms/vtex/resolvers/query.ts","../src/platforms/vtex/utils/sku.ts","../src/platforms/vtex/index.ts","../src/platforms/vtex/resolvers/seo.ts","../src/platforms/vtex/resolvers/faceValue.ts","../src/platforms/vtex/resolvers/aggregateRating.ts","../src/platforms/vtex/resolvers/review.ts","../src/platforms/vtex/resolvers/searchResult.ts","../src/platforms/vtex/resolvers/propertyValue.ts","../src/typeDefs/index.ts","../src/index.ts","../src/platforms/vtex/clients/index.ts","../src/platforms/vtex/loaders/index.ts","../src/platforms/vtex/loaders/sku.ts","../src/platforms/vtex/loaders/simulation.ts","../src/platforms/vtex/loaders/salesChannel.ts"],"sourcesContent":["import fetch from 'isomorphic-unfetch'\n\nexport const fetchAPI = async (info: RequestInfo, init?: RequestInit) => {\n  const response = await fetch(info, init)\n\n  if (response.ok) {\n    return response.status !== 204 ? response.json() : undefined\n  }\n\n  console.error(info, init, response)\n  const text = await response.text()\n\n  throw new Error(text)\n}\n","import { FACET_CROSS_SELLING_MAP } from '../../utils/facets'\nimport { fetchAPI } from '../fetch'\n\nimport type { PortalProduct } from './types/Product'\nimport type { Context, Options } from '../../index'\nimport type { Brand } from './types/Brand'\nimport type { CategoryTree } from './types/CategoryTree'\nimport type { OrderForm, OrderFormInputItem } from './types/OrderForm'\nimport type { PortalPagetype } from './types/Portal'\nimport type { Region, RegionInput } from './types/Region'\nimport type {\n  Simulation,\n  SimulationArgs,\n  SimulationOptions,\n} from './types/Simulation'\nimport type { Session } from './types/Session'\nimport type { Channel } from '../../utils/channel'\nimport type { SalesChannel } from './types/SalesChannel'\n\ntype ValueOf<T> = T extends Record<string, infer K> ? K : never\n\nconst BASE_INIT = {\n  method: 'POST',\n  headers: {\n    'content-type': 'application/json',\n  },\n}\n\nexport const VtexCommerce = (\n  { account, environment }: Options,\n  ctx: Context\n) => {\n  const base = `https://${account}.${environment}.com.br`\n\n  return {\n    catalog: {\n      salesChannel: (sc: string): Promise<SalesChannel> =>\n        fetchAPI(`${base}/api/catalog_system/pub/saleschannel/${sc}`),\n      brand: {\n        list: (): Promise<Brand[]> =>\n          fetchAPI(`${base}/api/catalog_system/pub/brand/list`),\n      },\n      category: {\n        tree: (depth = 3): Promise<CategoryTree[]> =>\n          fetchAPI(`${base}/api/catalog_system/pub/category/tree/${depth}`),\n      },\n      portal: {\n        pagetype: (slug: string): Promise<PortalPagetype> =>\n          fetchAPI(`${base}/api/catalog_system/pub/portal/pagetype/${slug}`),\n      },\n      products: {\n        crossselling: (\n          { type, productId, groupByProduct = true }: {\n            type: ValueOf<typeof FACET_CROSS_SELLING_MAP>;\n            productId: string;\n            groupByProduct?: boolean;\n          },\n        ): Promise<PortalProduct[]> => {\n          const params = new URLSearchParams({\n            sc: ctx.storage.channel.salesChannel,\n            groupByProduct: groupByProduct.toString(),\n          })\n\n          return fetchAPI(\n            `${base}/api/catalog_system/pub/products/crossselling/${type}/${productId}?${params}`,\n          )\n        },\n      },\n    },\n    checkout: {\n      simulation: (\n        args: SimulationArgs,\n        { salesChannel }: SimulationOptions = ctx.storage.channel\n      ): Promise<Simulation> => {\n        const params = new URLSearchParams({\n          sc: salesChannel,\n        })\n\n        return fetchAPI(\n          `${base}/api/checkout/pub/orderForms/simulation?${params.toString()}`,\n          {\n            ...BASE_INIT,\n            body: JSON.stringify(args),\n          }\n        )\n      },\n      orderForm: ({\n        id,\n        refreshOutdatedData = true,\n        channel = ctx.storage.channel,\n      }: {\n        id: string\n        refreshOutdatedData?: boolean\n        channel?: Required<Channel>\n      }): Promise<OrderForm> => {\n        const { salesChannel } = channel\n        const params = new URLSearchParams({\n          refreshOutdatedData: refreshOutdatedData.toString(),\n          sc: salesChannel,\n        })\n\n        return fetchAPI(\n          `${base}/api/checkout/pub/orderForm/${id}?${params.toString()}`,\n          BASE_INIT\n        )\n      },\n      updateOrderFormItems: ({\n        id,\n        orderItems,\n        allowOutdatedData = 'paymentData',\n        salesChannel = ctx.storage.channel.salesChannel,\n      }: {\n        id: string\n        orderItems: OrderFormInputItem[]\n        allowOutdatedData?: 'paymentData'\n        salesChannel?: string\n      }): Promise<OrderForm> => {\n        const params = new URLSearchParams({\n          allowOutdatedData,\n          sc: salesChannel,\n        })\n\n        return fetchAPI(\n          `${base}/api/checkout/pub/orderForm/${id}/items?${params}`,\n          {\n            ...BASE_INIT,\n            body: JSON.stringify({ orderItems }),\n            method: 'PATCH',\n          }\n        )\n      },\n      setCustomData: ({\n        id,\n        appId,\n        key,\n        value,\n      }: {\n        id: string\n        appId: string\n        key: string\n        value: string\n      }): Promise<OrderForm> => {\n        return fetchAPI(\n          `${base}/api/checkout/pub/orderForm/${id}/customData/${appId}/${key}`,\n          {\n            ...BASE_INIT,\n            body: JSON.stringify({ value }),\n            method: 'PUT',\n          },\n        )\n      },\n      region: async ({\n        postalCode,\n        country,\n        salesChannel,\n      }: RegionInput): Promise<Region> => {\n        return fetchAPI(\n          `${base}/api/checkout/pub/regions/?postalCode=${postalCode}&country=${country}&sc=${\n            salesChannel ?? ''\n          }`\n        )\n      },\n    },\n    session: (search: string): Promise<Session> => {\n      const params = new URLSearchParams(search)\n\n      params.set(\n        'items',\n        'profile.id,profile.email,profile.firstName,profile.lastName,store.channel,store.countryCode,store.cultureInfo,store.currencyCode,store.currencySymbol'\n      )\n\n      return fetchAPI(`${base}/api/sessions?${params.toString()}`, {\n        method: 'POST',\n        headers: {\n          'content-type': 'application/json',\n          cookie: ctx.headers.cookie,\n        },\n        body: '{}',\n      })\n    },\n  }\n}\n","import { fetchAPI } from '../fetch'\nimport type { IStoreSelectedFacet } from '../../../../__generated__/schema'\nimport type { Context, Options } from '../../index'\nimport type { SelectedFacet } from '../../utils/facets'\nimport type {\n  Facet,\n  FacetValueBoolean,\n  FacetSearchResult,\n} from './types/FacetSearchResult'\nimport type {\n  ProductSearchResult,\n  Suggestion,\n} from './types/ProductSearchResult'\n\nexport type Sort =\n  | 'price:desc'\n  | 'price:asc'\n  | 'orders:desc'\n  | 'name:desc'\n  | 'name:asc'\n  | 'release:desc'\n  | 'discount:desc'\n  | ''\n\nexport interface SearchArgs {\n  query?: string\n  page: number\n  count: number\n  type: 'product_search' | 'facets'\n  sort?: Sort\n  selectedFacets?: SelectedFacet[]\n  fuzzy?: '0' | '1' | 'auto'\n  hideUnavailableItems?: boolean\n}\n\nexport interface ProductLocator {\n  field: 'id' | 'slug'\n  value: string\n}\n\nconst POLICY_KEY = 'trade-policy'\nconst REGION_KEY = 'region-id'\nconst CHANNEL_KEYS = new Set([POLICY_KEY, REGION_KEY])\n\nexport const isFacetBoolean = (\n  facet: Facet\n): facet is Facet<FacetValueBoolean> => facet.type === 'TEXT'\n\nexport const IntelligentSearch = (\n  { account, environment, hideUnavailableItems }: Options,\n  ctx: Context\n) => {\n  const base = `https://${account}.${environment}.com.br/api/io`\n\n  const getPolicyFacet = (): IStoreSelectedFacet | null => {\n    const { salesChannel } = ctx.storage.channel\n\n    if (!salesChannel) {\n      return null\n    }\n\n    return {\n      key: POLICY_KEY,\n      value: salesChannel,\n    }\n  }\n\n  const getRegionFacet = (): IStoreSelectedFacet | null => {\n    const { regionId } = ctx.storage.channel\n\n    if (!regionId) {\n      return null\n    }\n\n    return {\n      key: REGION_KEY,\n      value: regionId,\n    }\n  }\n\n  const addDefaultFacets = (facets: SelectedFacet[]) => {\n    const withDefaltFacets = facets.filter(({ key }) => !CHANNEL_KEYS.has(key))\n\n    const policyFacet =\n      facets.find(({ key }) => key === POLICY_KEY) ?? getPolicyFacet()\n\n    const regionFacet =\n      facets.find(({ key }) => key === REGION_KEY) ?? getRegionFacet()\n\n    if (policyFacet !== null) {\n      withDefaltFacets.push(policyFacet)\n    }\n\n    if (regionFacet !== null) {\n      withDefaltFacets.push(regionFacet)\n    }\n\n    return withDefaltFacets\n  }\n\n  const search = <T>({\n    query = '',\n    page,\n    count,\n    sort = '',\n    selectedFacets = [],\n    type,\n    fuzzy = 'auto',\n  }: SearchArgs): Promise<T> => {\n    const params = new URLSearchParams({\n      page: (page + 1).toString(),\n      count: count.toString(),\n      query,\n      sort,\n      fuzzy,\n      locale: ctx.storage.locale,\n    })\n\n    if (hideUnavailableItems !== undefined) {\n      params.append('hideUnavailableItems', hideUnavailableItems.toString())\n    }\n\n    const pathname = addDefaultFacets(selectedFacets)\n      .map(({ key, value }) => `${key}/${value}`)\n      .join('/')\n\n    return fetchAPI(\n      `${base}/_v/api/intelligent-search/${type}/${pathname}?${params.toString()}`\n    )\n  }\n\n  const products = (args: Omit<SearchArgs, 'type'>) =>\n    search<ProductSearchResult>({ ...args, type: 'product_search' })\n\n  const suggestedTerms = (\n    args: Omit<SearchArgs, 'type'>\n  ): Promise<Suggestion> => {\n    const params = new URLSearchParams({\n      query: args.query?.toString() ?? '',\n      locale: ctx.storage.locale,\n    })\n\n    return fetchAPI(\n      `${base}/_v/api/intelligent-search/search_suggestions?${params.toString()}`\n    )\n  }\n\n  const topSearches = (): Promise<Suggestion> => {\n    const params = new URLSearchParams({\n      locale: ctx.storage.locale,\n    })\n\n    return fetchAPI(\n      `${base}/_v/api/intelligent-search/top_searches?${params.toString()}`\n    )\n  }\n\n  const facets = (args: Omit<SearchArgs, 'type'>) =>\n    search<FacetSearchResult>({ ...args, type: 'facets' })\n\n  return {\n    facets,\n    products,\n    suggestedTerms,\n    topSearches,\n  }\n}\n","/**\n * Client for SP, Intelligent search's analytics event API\n * More info at: https://www.notion.so/vtexhandbook/Event-API-Documentation-48eee26730cf4d7f80f8fd7262231f84\n */\nimport { fetchAPI } from '../fetch'\nimport type { Options, Context } from '../../index'\n\nconst THIRTY_MINUTES_S = 30 * 60\nconst ONE_YEAR_S = 365 * 24 * 3600\n\nconst randomUUID = () => (Math.random() * 1e6).toFixed(0)\n\nconst timelapsed = (past: number) => (Date.now() - past) / 1e3\n\nconst createId = (expiresSecond: number) => {\n  let payload = randomUUID()\n  let createdAt = Date.now()\n\n  return () => {\n    if (timelapsed(createdAt) > expiresSecond) {\n      payload = randomUUID()\n      createdAt = Date.now()\n    }\n\n    return payload\n  }\n}\n\nconst user = {\n  anonymous: createId(ONE_YEAR_S),\n  session: createId(THIRTY_MINUTES_S),\n}\n\nexport type SearchEvent = {\n  type: 'search.query'\n  text: string // 'zapatilha'\n  misspelled: boolean\n  match: number\n  operator: 'and' | 'or'\n  session?: string\n  anonymous?: string\n}\n\nexport const SP = ({ account }: Options, _: Context) => {\n  const base = `https://sp.vtex.com/event-api/v1/${account}/event`\n\n  const sendEvent = (options: SearchEvent) => {\n    return fetchAPI(base, {\n      method: 'POST',\n      body: JSON.stringify({\n        ...options,\n        agent: '@faststore/api',\n        anonymous: user.anonymous(),\n        session: user.session(),\n        // session: 'zZlNhqz1vFJP6iPG5Oqtt',\n        // anonymous: 'Om1TNluGvgmSgU5OOTvkkd',\n      }),\n      headers: {\n        'content-type': 'application/json',\n      },\n    })\n  }\n\n  return {\n    sendEvent,\n  }\n}\n","import type { Product, Item } from '../clients/search/types/ProductSearchResult'\n\nexport type EnhancedSku = Item & { isVariantOf: Product }\n\nexport const enhanceSku = (item: Item, product: Product): EnhancedSku => ({\n  ...item,\n  isVariantOf: product,\n})\n","type ErrorType = 'BadRequestError' | 'NotFoundError' | 'RedirectError'\n\ninterface Extension {\n  type: ErrorType\n  status: number\n}\n\nclass FastStoreError<T extends Extension = Extension> extends Error {\n  constructor(public extensions: T, message?: string) {\n    super(message)\n    this.name = 'FastStoreError'\n  }\n}\n\nexport class BadRequestError extends FastStoreError {\n  constructor(message?: string) {\n    super({ status: 400, type: 'BadRequestError' }, message)\n  }\n}\n\nexport class NotFoundError extends FastStoreError {\n  constructor(message?: string) {\n    super({ status: 404, type: 'NotFoundError' }, message)\n  }\n}\n\nexport const isFastStoreError = (error: any): error is FastStoreError =>\n  error?.name === 'FastStoreError'\n\nexport const isNotFoundError = (error: any): error is NotFoundError =>\n  error?.extensions?.type === 'NotFoundError'\n\nexport const isBadRequestError = (error: any): error is BadRequestError =>\n  error?.extensions?.type === 'BadRequestError'\n","import DataLoader from 'dataloader'\nimport pLimit from 'p-limit'\n\nimport { NotFoundError } from '../../errors'\nimport type { CollectionPageType } from '../clients/commerce/types/Portal'\nimport type { Options } from '..'\nimport type { Clients } from '../clients'\n\n// Limits concurrent requests to 20 so that they don't timeout\nconst CONCURRENT_REQUESTS_MAX = 20\n\nconst collectionPageTypes = new Set([\n  'brand',\n  'category',\n  'department',\n  'subcategory',\n] as const)\n\nexport const isCollectionPageType = (x: any): x is CollectionPageType =>\n  typeof x.pageType === 'string' &&\n  collectionPageTypes.has(x.pageType.toLowerCase())\n\nexport const getCollectionLoader = (_: Options, clients: Clients) => {\n  const limit = pLimit(CONCURRENT_REQUESTS_MAX)\n\n  const loader = async (\n    slugs: readonly string[]\n  ): Promise<CollectionPageType[]> => {\n    return Promise.all(\n      slugs.map((slug: string) =>\n        limit(async () => {\n          const page = await clients.commerce.catalog.portal.pagetype(slug)\n\n          if (isCollectionPageType(page)) {\n            return page\n          }\n\n          throw new NotFoundError(\n            `Catalog returned ${page.pageType} for slug: ${slug}. This usually happens when there is more than one category with the same name in the same category tree level.`\n          )\n        })\n      )\n    )\n  }\n\n  return new DataLoader<string, CollectionPageType>(loader, {\n    // DataLoader is being used to cache requests, not to batch them\n    batch: false,\n  })\n}\n","import type { CommertialOffer } from '../clients/search/types/ProductSearchResult'\n\nexport const inStock = (offer: Pick<CommertialOffer, 'AvailableQuantity'>) =>\n  offer.AvailableQuantity > 0\n\nexport const price = (offer: Pick<CommertialOffer, 'spotPrice'>) =>\n  offer.spotPrice ?? 0\nexport const sellingPrice = (offer: CommertialOffer) => offer.Price ?? 0\n\nexport const availability = (available: boolean) =>\n  available ? 'https://schema.org/InStock' : 'https://schema.org/OutOfStock'\n\n// Smallest Available Spot Price First\nexport const bestOfferFirst = (\n  a: Pick<CommertialOffer, 'AvailableQuantity' | 'spotPrice'>,\n  b: Pick<CommertialOffer, 'AvailableQuantity' | 'spotPrice'>\n) => {\n  if (inStock(a) && !inStock(b)) {\n    return -1\n  }\n\n  if (!inStock(a) && inStock(b)) {\n    return 1\n  }\n\n  return price(a) - price(b)\n}\n\nexport const inStockOrderFormItem = (itemAvailability: string) =>\n  itemAvailability === 'available'\n","import { inStock, price } from '../utils/productStock'\nimport type { StoreProduct } from './product'\nimport type { PromiseType } from '../../../typings'\nimport type { Resolver } from '..'\n\ntype Root = PromiseType<ReturnType<typeof StoreProduct.offers>>\n\nexport const StoreAggregateOffer: Record<string, Resolver<Root>> & {\n  offers: Resolver<Root, any, Root>\n} = {\n  highPrice: (offers) => {\n    const availableOffers = offers.filter(inStock)\n    const highOffer = availableOffers[availableOffers.length - 1]\n\n    return highOffer != null ? price(highOffer) : 0\n  },\n  lowPrice: (offers) => {\n    const [lowOffer] = offers.filter(inStock)\n\n    return lowOffer ? price(lowOffer) : 0\n  },\n  offerCount: (offers) => offers.length,\n  priceCurrency: async (_, __, ctx) => {\n    const { \n      loaders: { salesChannelLoader }, \n      storage: { channel } \n    } = ctx\n\n    const sc = await salesChannelLoader.load(channel.salesChannel);\n    \n    return sc.CurrencyCode ?? '';\n  },\n  offers: (offers) => offers,\n}\n","/* eslint-disable no-useless-escape */\n/**\n * VTEX catalog slugify function\n *\n * Copied from:\n * https://github.com/vtex/rewriter/blob/1ce2010783e0586cab42534ce2fb7a983d8a3a84/node/clients/catalog.ts#L72\n *\n * Sometimes, we need to slugify strings for creating urls. An example is the\n * brand urls, where we create them from the brand's name.\n * This slugify function should match exactly what VTEX catalog generates. Any mismatch\n * will lead to broken links.\n * Hopefully, we had this function implemented on VTEX IO and we've been using it for\n * years now. However, looking at the code, I think we can save lots of computing. I'm\n * in a hurry for doing these tests now, so I'll leave a small TODO.\n *\n * TODO: Research for better ways of computing this slugify function. Things I'd try are:\n * - Join those 3 regexs for special characters into a single one.\n * - Replace the regexp of `removeDiacritics` function with a Map. We can make the complexity\n * of this function be O(n) with n=string.length\n *\n */\nconst from =\n  'ÁÄÂÀÃÅČÇĆĎÉĚËÈÊẼĔȆÍÌÎÏŇÑÓÖÒÔÕØŘŔŠŤÚŮÜÙÛÝŸŽáäâàãåčçćďéěëèêẽĕȇíìîïňñóöòôõøðřŕšťúůüùûýÿžþÞĐđßÆa'\n\nconst to =\n  'AAAAAACCCDEEEEEEEEIIIINNOOOOOORRSTUUUUUYYZaaaaaacccdeeeeeeeeiiiinnooooooorrstuuuuuyyzbBDdBAa'\n\nconst removeDiacritics = (str: string) => {\n  let newStr = str.slice(0)\n\n  for (let i = 0; i < from.length; i++) {\n    newStr = newStr.replace(new RegExp(from.charAt(i), 'g'), to.charAt(i))\n  }\n\n  return newStr\n}\n\nconst slugifySpecialCharacters = (str: string) => {\n  return str.replace(/[·/_,:]/, '-')\n}\n\nexport function slugify(str: string) {\n  const noCommas = str.replace(/,/g, '')\n  const replaced = noCommas.replace(/[*+~.()'\"!:@&\\[\\]`/ %$#?{}|><=_^]/g, '-')\n  const slugified = slugifySpecialCharacters(removeDiacritics(replaced))\n\n  return slugified.toLowerCase()\n}\n","import { isCollectionPageType } from '../loaders/collection'\nimport { slugify } from '../utils/slugify'\nimport type { Resolver } from '..'\nimport type { Brand } from '../clients/commerce/types/Brand'\nimport type { CategoryTree } from '../clients/commerce/types/CategoryTree'\nimport type { CollectionPageType } from '../clients/commerce/types/Portal'\n\ntype Root = Brand | (CategoryTree & { level: number }) | CollectionPageType\n\nconst isBrand = (x: any): x is Brand | CollectionPageType =>\n  x.type === 'brand' ||\n  (isCollectionPageType(x) && x.pageType.toLowerCase() === 'brand')\n\nconst slugifyRoot = (root: Root) => {\n  if (isBrand(root)) {\n    return slugify(root.name)\n  }\n\n  if (isCollectionPageType(root)) {\n    return new URL(`https://${root.url}`).pathname.slice(1).toLowerCase()\n  }\n\n  return new URL(root.url).pathname.slice(1).toLowerCase()\n}\n\nexport const StoreCollection: Record<string, Resolver<Root>> = {\n  id: ({ id }) => id.toString(),\n  slug: (root) => slugifyRoot(root),\n  seo: (root) =>\n    isBrand(root) || isCollectionPageType(root)\n      ? {\n          title: root.title,\n          description: root.metaTagDescription,\n        }\n      : {\n          title: root.Title,\n          description: root.MetaTagDescription,\n        },\n  type: (root) =>\n    isBrand(root)\n      ? 'Brand'\n      : isCollectionPageType(root)\n      ? root.pageType\n      : root.level === 0\n      ? 'Department'\n      : 'Category',\n  meta: (root) => {\n    const slug = slugifyRoot(root)\n\n    return isBrand(root)\n      ? {\n          selectedFacets: [{ key: 'brand', value: slug }],\n        }\n      : {\n          selectedFacets: slug.split('/').map((segment, index) => ({\n            key: `category-${index + 1}`,\n            value: segment,\n          })),\n        }\n  },\n  breadcrumbList: async (root, _, ctx) => {\n    const {\n      loaders: { collectionLoader },\n    } = ctx\n\n    const slug = slugifyRoot(root)\n\n    /**\n     * Split slug into segments so we fetch all data for\n     * the breadcrumb. For instance, if we get `/foo/bar`\n     * we need all metadata for both `/foo` and `/bar` and\n     * thus we need to fetch pageType for `/foo` and `/bar`\n     */\n    const segments = slug.split('/').filter((segment) => Boolean(segment))\n    const slugs = segments.map((__, index) =>\n      segments.slice(0, index + 1).join('/')\n    )\n\n    const collections = await Promise.all(\n      slugs.map((s) => collectionLoader.load(s))\n    )\n\n    return {\n      itemListElement: collections.map((collection, index) => ({\n        item: new URL(`https://${collection.url}`).pathname.toLowerCase(),\n        name: collection.name,\n        position: index + 1,\n      })),\n      numberOfItems: collections.length,\n    }\n  },\n}\n","export interface Channel {\n  regionId?: string\n  salesChannel?: string\n}\n\nexport default class ChannelMarshal {\n  public static parse(channelString: string): Required<Channel> {\n    try {\n      const parsedChannel = JSON.parse(channelString) as Channel\n\n      return {\n        regionId: parsedChannel.regionId ?? '',\n        salesChannel: parsedChannel.salesChannel ?? '',\n      }\n    } catch (error) {\n      console.error(error)\n\n      throw new Error('Malformed channel string')\n    }\n  }\n\n  public static stringify(channel: Channel): string {\n    return JSON.stringify(channel)\n  }\n}\n","import ChannelMarshal from './channel'\nimport type { Maybe } from '../../../__generated__/schema'\nimport { BadRequestError } from '../../errors'\n\nexport interface SelectedFacet {\n  key: string\n  value: string\n}\n\nexport interface CrossSellingFacet {\n  key: keyof typeof FACET_CROSS_SELLING_MAP\n  value: string\n}\n\nexport const FACET_CROSS_SELLING_MAP = {\n  buy: \"whoboughtalsobought\",\n  view: \"whosawalsosaw\",\n  similars: \"similars\",\n  viewAndBought: \"whosawalsobought\",\n  accessories: \"accessories\",\n  suggestions: \"suggestions\",\n} as const\n\n/**\n * Transform facets from the store to VTEX platform facets.\n * For instance, the channel in Store becomes trade-policy and regionId in VTEX's realm\n * */\nexport const transformSelectedFacet = ({ key, value }: SelectedFacet) => {\n  switch (key) {\n    case 'channel': {\n      const channel = ChannelMarshal.parse(value)\n      const channelFacets = [\n        { key: 'trade-policy', value: channel.salesChannel },\n      ]\n\n      if (channel.regionId) {\n        channelFacets.push({ key: 'region-id', value: channel.regionId })\n      }\n\n      return channelFacets\n    }\n\n    case 'locale': {\n      return [] // remove this facet from search\n    }\n\n    case 'price': {\n      return { key, value: value.replace('-to-', ':') }\n    }\n\n    case \"buy\":\n    case \"view\":\n    case \"similars\":\n    case \"viewAndBought\":\n    case \"accessories\":\n    case \"suggestions\": {\n      return [] // remove this facet from search\n    }\n\n    default:\n      return { key, value }\n  }\n}\n\nexport const parseRange = (range: string): [number, number] | null => {\n  const splitted = range.split(':').map(Number)\n\n  if (\n    splitted.length !== 2 ||\n    Number.isNaN(splitted[0]) ||\n    Number.isNaN(splitted[1])\n  ) {\n    return null\n  }\n\n  return splitted as [number, number]\n}\n\nexport const isCrossSelling = (\n  x: string,\n): x is CrossSellingFacet['key'] =>\n  typeof (FACET_CROSS_SELLING_MAP as Record<string, string>)[x] === \"string\"\n\nexport const findCrossSelling = (facets?: Maybe<SelectedFacet[]>) => {\n  const filtered = facets?.filter((x): x is CrossSellingFacet => isCrossSelling(x.key))\n\n  if (Array.isArray(filtered) && filtered.length > 1) {\n    throw new BadRequestError(\n      `You passed ${filtered.length} cross selling facets but only one is allowed. Please leave one of the following facet: ${filtered.map(x => x.key).join(',')}`\n    )\n  }\n\n  return filtered?.[0] ?? null\n}\n\nexport const findSlug = (facets?: Maybe<SelectedFacet[]>) =>\n  facets?.find((x) => x.key === 'slug')?.value ?? null\n\nexport const findSkuId = (facets?: Maybe<SelectedFacet[]>) =>\n  facets?.find((x) => x.key === 'id')?.value ?? null\n\nexport const findLocale = (facets?: Maybe<SelectedFacet[]>) =>\n  facets?.find((x) => x.key === 'locale')?.value ?? null\n\nexport const findChannel = (facets?: Maybe<SelectedFacet[]>) =>\n  facets?.find((facet) => facet.key === 'channel')?.value ?? null\n","/**\n * More info at: https://en.wikipedia.org/wiki/Order_statistic\n */\n\n// O(n) search to find the max of an array\nexport const min = <T>(array: T[], cmp: (a: T, b: T) => number) => {\n  let best = 0\n\n  for (let curr = 1; curr < array.length; curr++) {\n    if (cmp(array[best], array[curr]) > 0) {\n      best = curr\n    }\n  }\n\n  return array[best]\n}\n","import { parseRange } from '../utils/facets'\nimport { min } from '../utils/orderStatistics'\nimport type {\n  FacetValueBoolean,\n  Facet,\n  FacetValueRange,\n} from '../clients/search/types/FacetSearchResult'\nimport type { Resolver } from '..'\n\ntype Root = Facet\n\nexport const StoreFacet: Record<string, Resolver<Root>> = {\n  __resolveType: ({ type }) =>\n    type === 'TEXT' ? 'StoreFacetBoolean' : 'StoreFacetRange',\n}\n\nexport const StoreFacetBoolean: Record<\n  string,\n  Resolver<Facet<FacetValueBoolean>>\n> = {\n  key: ({ key }) => key,\n  label: ({ name }) => name,\n  values: ({ values }) => values.sort((a, b) => a.name.localeCompare(b.name)),\n}\n\nexport const StoreFacetRange: Record<\n  string,\n  Resolver<Facet<FacetValueRange>>\n> = {\n  key: ({ key }) => key,\n  label: ({ name }) => name,\n  min: ({ values, key }, _, { storage: { searchArgs } }) => {\n    /**\n     * Fetch the selected range the user queried.\n     *\n     * This is necessary because, differently from boolean facets, Search API does\n     * not return the selected values, making us have to implement it in here\n     */\n    const selectedRange = parseRange(\n      searchArgs?.selectedFacets?.find((facet) => facet.key === key)?.value ??\n        ''\n    )\n\n    const facet = min(values, (a, b) => a.range.from - b.range.from)\n    const globalMin = facet?.range.from ?? 0\n\n    return {\n      selected: selectedRange?.[0] ?? globalMin,\n      absolute: globalMin,\n    }\n  },\n  max: ({ values, key }, _, { storage: { searchArgs } }) => {\n    /**\n     * Fetch the selected range the user queried.\n     *\n     * This is necessary because, differently from boolean facets, Search API does\n     * not return the selected values, making us have to implement it in here\n     */\n    const selectedRange = parseRange(\n      searchArgs?.selectedFacets?.find((facet) => facet.key === key)?.value ??\n        ''\n    )\n\n    const facet = min(values, (a, b) => b.range.to - a.range.to)\n    const globalMax = facet?.range.to ?? 0\n\n    return {\n      selected: selectedRange?.[1] ?? globalMax,\n      absolute: globalMax,\n    }\n  },\n}\n","import crypto from 'crypto'\n\nexport const md5 = (payload: string) =>\n  crypto.createHash('md5').update(payload).digest('hex')\n","import type { IStorePropertyValue } from '../../../__generated__/schema'\nimport type { Attachment } from '../clients/commerce/types/OrderForm'\nimport { md5 } from './md5'\n\nexport const VALUE_REFERENCES = {\n  attachment: 'ATTACHMENT',\n  specification: 'SPECIFICATION',\n} as const\n\nexport function attachmentToPropertyValue(attachment: Attachment) {\n  return {\n    name: attachment.name,\n    value: attachment.content,\n    valueReference: VALUE_REFERENCES.attachment,\n  }\n}\n\nexport function getPropertyId(item: IStorePropertyValue) {\n  return md5(\n    `${item.name}:${JSON.stringify(item.value)}:${item.valueReference}`\n  )\n}\n","import deepEquals from 'fast-deep-equal'\n\nimport { md5 } from '../utils/md5'\nimport type {\n  IStoreCart,\n  IStoreOffer,\n  IStoreOrder,\n  IStorePropertyValue,\n} from '../../../__generated__/schema'\nimport type {\n  OrderForm,\n  OrderFormInputItem,\n  OrderFormItem,\n} from '../clients/commerce/types/OrderForm'\nimport type { Context } from '..'\nimport {\n  attachmentToPropertyValue,\n  getPropertyId,\n  VALUE_REFERENCES,\n} from '../utils/propertyValue'\n\ntype Indexed<T> = T & { index?: number }\n\nconst isAttachment = (value: IStorePropertyValue) =>\n  value.valueReference === VALUE_REFERENCES.attachment\n\nconst getId = (item: IStoreOffer) =>\n  [\n    item.itemOffered.sku,\n    item.seller.identifier,\n    item.price,\n    item.itemOffered.additionalProperty\n      ?.filter(isAttachment)\n      .map(getPropertyId)\n      .join('-'),\n  ]\n    .filter(Boolean)\n    .join('::')\n\nconst orderFormItemToOffer = (\n  item: OrderFormItem,\n  index?: number\n): Indexed<IStoreOffer> => ({\n  listPrice: item.listPrice / 100,\n  price: item.sellingPrice / 100,\n  quantity: item.quantity,\n  seller: { identifier: item.seller },\n  itemOffered: {\n    sku: item.id,\n    image: [],\n    name: item.name,\n    additionalProperty: item.attachments.map(attachmentToPropertyValue),\n  },\n  index,\n})\n\nconst offerToOrderItemInput = (\n  offer: Indexed<IStoreOffer>\n): OrderFormInputItem => ({\n  quantity: offer.quantity,\n  seller: offer.seller.identifier,\n  id: offer.itemOffered.sku,\n  index: offer.index,\n  attachments: (\n    offer.itemOffered.additionalProperty?.filter(isAttachment) ?? []\n  ).map((attachment) => ({\n    name: attachment.name,\n    content: attachment.value,\n  })),\n})\n\nconst groupById = (offers: IStoreOffer[]): Map<string, IStoreOffer> =>\n  offers.reduce((acc, item) => {\n    const id = getId(item)\n\n    acc.set(id, acc.get(id) ?? item)\n\n    return acc\n  }, new Map<string, IStoreOffer>())\n\nconst equals = (storeOrder: IStoreOrder, orderForm: OrderForm) => {\n  const pick = (item: Indexed<IStoreOffer>, index: number) => ({\n    ...item,\n    itemOffered: {\n      sku: item.itemOffered.sku,\n    },\n    index,\n  })\n\n  const orderFormItems = orderForm.items.map(orderFormItemToOffer).map(pick)\n  const storeOrderItems = storeOrder.acceptedOffer.map(pick)\n\n  const isSameOrder = storeOrder.orderNumber === orderForm.orderFormId\n  const orderItemsAreSync = deepEquals(orderFormItems, storeOrderItems)\n\n  return isSameOrder && orderItemsAreSync\n}\n\nconst orderFormToCart = async (\n  form: OrderForm,\n  skuLoader: Context['loaders']['skuLoader']\n) => {\n  return {\n    order: {\n      orderNumber: form.orderFormId,\n      acceptedOffer: form.items.map(async (item) => ({\n        ...item,\n        product: await skuLoader.load(item.id), // TODO: add channel\n      })),\n    },\n    messages: form.messages.map(({ text, status }) => ({\n      text,\n      status: status.toUpperCase(),\n    })),\n  }\n}\n\nconst getOrderFormEtag = ({ items }: OrderForm) => md5(JSON.stringify(items))\n\nconst setOrderFormEtag = async (\n  form: OrderForm,\n  commerce: Context['clients']['commerce']\n) => {\n  try {\n    const orderForm = await commerce.checkout.setCustomData({\n      id: form.orderFormId,\n      appId: 'faststore',\n      key: 'cartEtag',\n      value: getOrderFormEtag(form),\n    })\n\n    return orderForm\n  } catch (err) {\n    console.error(\n      'Error while setting custom data to orderForm.\\n Make sure to add the following custom app to the orderForm: \\n{\"fields\":[\"cartEtag\"],\"id\":\"faststore\",\"major\":1}.\\n More info at: https://developers.vtex.com/vtex-rest-api/docs/customizable-fields-with-checkout-api'\n    )\n\n    throw err\n  }\n}\n\n/**\n * Checks if cartEtag stored on customData is up to date\n * @description If cartEtag is not up to date, this means that\n * another system changed the cart, like Checkout UI or Order Placed\n */\nconst isOrderFormStale = (form: OrderForm) => {\n  const faststoreData = form.customData?.customApps.find(\n    (app) => app.id === 'faststore'\n  )\n\n  const oldEtag = faststoreData?.fields?.cartEtag\n\n  if (oldEtag == null) {\n    return true\n  }\n\n  const newEtag = getOrderFormEtag(form)\n\n  return newEtag !== oldEtag\n}\n\n/**\n * This resolver implements the optimistic cart behavior. The main idea in here\n * is that we receive a cart from the UI (as query params) and we validate it with\n * the commerce platform. If the cart is valid, we return null, if the cart is\n * invalid according to the commerce platform, we return the new cart the UI should use\n * instead.\n *\n * The algorithm is something like:\n * 1. Fetch orderForm from VTEX\n * 2. Compute delta changes between the orderForm and the UI's cart\n * 3. Update the orderForm in VTEX platform accordingly\n * 4. If any changes were made, send to the UI the new cart. Null otherwise\n */\nexport const validateCart = async (\n  _: unknown,\n  { cart: { order } }: { cart: IStoreCart },\n  ctx: Context\n) => {\n  const { enableOrderFormSync } = ctx.storage.flags\n  const { orderNumber, acceptedOffer } = order\n  const {\n    clients: { commerce },\n    loaders: { skuLoader },\n  } = ctx\n\n  // Step1: Get OrderForm from VTEX Commerce\n  const orderForm = await commerce.checkout.orderForm({\n    id: orderNumber,\n  })\n\n  // Step1.5: Check if another system changed the orderForm with this orderNumber\n  // If so, this means the user interacted with this cart elsewhere and expects\n  // to see this new cart state instead of what's stored on the user's browser.\n  if (enableOrderFormSync === true) {\n    const isStale = isOrderFormStale(orderForm)\n\n    if (isStale === true && orderNumber) {\n      const newOrderForm = await setOrderFormEtag(orderForm, commerce)\n\n      return orderFormToCart(newOrderForm, skuLoader)\n    }\n  }\n\n  // Step2: Process items from both browser and checkout so they have the same shape\n  const browserItemsById = groupById(acceptedOffer)\n  const originItemsById = groupById(orderForm.items.map(orderFormItemToOffer))\n  const browserItems = Array.from(browserItemsById.values()) // items on the user's browser\n  const originItems = Array.from(originItemsById.values()) // items on the VTEX platform backend\n\n  // Step3: Compute delta changes\n  const { itemsToAdd, itemsToUpdate } = browserItems.reduce(\n    (acc, item) => {\n      const maybeOriginItem = originItemsById.get(getId(item))\n\n      if (!maybeOriginItem) {\n        acc.itemsToAdd.push(item)\n      } else {\n        acc.itemsToUpdate.push({\n          ...maybeOriginItem,\n          quantity: item.quantity,\n        })\n      }\n\n      return acc\n    },\n    {\n      itemsToAdd: [] as IStoreOffer[],\n      itemsToUpdate: [] as IStoreOffer[],\n    }\n  )\n\n  const itemsToDelete = originItems\n    .filter((item) => !browserItemsById.has(getId(item)))\n    .map((item) => ({ ...item, quantity: 0 }))\n\n  const changes = [...itemsToAdd, ...itemsToUpdate, ...itemsToDelete].map(\n    offerToOrderItemInput\n  )\n\n  if (changes.length === 0) {\n    return null\n  }\n\n  // Step4: Apply delta changes to order form\n  const updatedOrderForm = await commerce.checkout\n    // update orderForm items\n    .updateOrderFormItems({\n      id: orderForm.orderFormId,\n      orderItems: changes,\n    })\n    // update orderForm etag so we know last time we touched this orderForm\n    .then((form) =>\n      enableOrderFormSync ? setOrderFormEtag(form, commerce) : form\n    )\n\n  // Step5: If no changes detected before/after updating orderForm, the order is validated\n  if (equals(order, updatedOrderForm)) {\n    return null\n  }\n\n  // Step6: There were changes, convert orderForm to StoreCart\n  return orderFormToCart(updatedOrderForm, skuLoader)\n}\n","import { validateCart } from './validateCart'\nimport { validateSession } from './validateSession'\n\nexport const Mutation = {\n  validateCart,\n  validateSession,\n}\n","import deepEquals from 'fast-deep-equal'\n\nimport ChannelMarshal from '../utils/channel'\nimport type { Context } from '..'\nimport type {\n  MutationValidateSessionArgs,\n  StoreSession,\n} from '../../../__generated__/schema'\n\nexport const validateSession = async (\n  _: any,\n  { session: oldSession, search }: MutationValidateSessionArgs,\n  { clients }: Context\n): Promise<StoreSession | null> => {\n  const channel = ChannelMarshal.parse(oldSession.channel ?? '')\n  const postalCode = String(oldSession.postalCode ?? '').replace(/\\D/g, '')\n  const country = oldSession.country ?? ''\n\n  const params = new URLSearchParams(search)\n\n  params.set('sc', params.get('sc') ?? channel.salesChannel)\n\n  const [regionData, sessionData] = await Promise.all([\n    postalCode\n      ? clients.commerce.checkout.region({ postalCode, country })\n      : Promise.resolve(null),\n    clients.commerce.session(params.toString()).catch(() => null),\n  ])\n\n  const profile = sessionData?.namespaces.profile ?? null\n  const store = sessionData?.namespaces.store ?? null\n\n  const newSession = {\n    ...oldSession,\n    currency: {\n      code: store?.currencyCode.value ?? oldSession.currency.code,\n      symbol: store?.currencySymbol.value ?? oldSession.currency.symbol,\n    },\n    country: store?.countryCode.value ?? oldSession.country,\n    channel: ChannelMarshal.stringify({\n      salesChannel: store?.channel?.value ?? channel.salesChannel,\n      regionId: regionData?.[0]?.id ?? channel.regionId,\n    }),\n    person: profile?.id\n      ? {\n          id: profile.id?.value ?? '',\n          email: profile.email?.value ?? '',\n          givenName: profile.firstName?.value ?? '',\n          familyName: profile.lastName?.value ?? '',\n        }\n      : null,\n  }\n\n  if (deepEquals(oldSession, newSession)) {\n    return null\n  }\n\n  return newSession\n}\n","import type { GraphQLScalarSerializer } from 'graphql'\nimport { GraphQLScalarType } from 'graphql'\nimport { Kind } from 'graphql/language'\n\nexport const ObjectOrString = new GraphQLScalarType({\n  name: 'ObjectOrString',\n  description:\n    'A string or the string representation of an object (a stringified object).',\n  parseValue: toObjectOrString,\n  serialize: stringify,\n  parseLiteral(ast) {\n    if (ast.kind === Kind.STRING) {\n      return getValueAsObjectOrString(ast.value)\n    }\n\n    return null\n  },\n})\n\nfunction toObjectOrString(value: GraphQLScalarSerializer<any>) {\n  if (typeof value === 'string') {\n    return getValueAsObjectOrString(value)\n  }\n\n  return null\n}\n\nfunction getValueAsObjectOrString(value: string) {\n  try {\n    return JSON.parse(value)\n  } catch (e) {\n    return value\n  }\n}\n\nfunction stringify(value: GraphQLScalarSerializer<any>) {\n  if (typeof value === 'object') {\n    return JSON.stringify(value)\n  }\n\n  if (typeof value === 'string') {\n    return value\n  }\n\n  return null\n}\n","import {\n  availability,\n  inStock,\n  inStockOrderFormItem,\n  price,\n  sellingPrice,\n} from '../utils/productStock'\nimport type { Resolver } from '..'\nimport type { StoreAggregateOffer } from './aggregateOffer'\nimport type { ArrayElementType } from '../../../typings'\nimport type { EnhancedSku } from '../utils/enhanceSku'\nimport type { OrderFormItem } from '../clients/commerce/types/OrderForm'\n\ntype OrderFormProduct = OrderFormItem & { product: EnhancedSku }\ntype SearchProduct = ArrayElementType<\n  ReturnType<typeof StoreAggregateOffer.offers>\n>\ntype Root = SearchProduct | OrderFormProduct\n\nconst isSearchItem = (item: Root): item is SearchProduct =>\n  'Price' in item && 'seller' in item && 'product' in item\n\nconst isOrderFormItem = (item: Root): item is OrderFormProduct =>\n  'skuName' in item\n\nexport const StoreOffer: Record<string, Resolver<Root>> = {\n  priceCurrency: async (_, __, ctx) => {\n    const { \n      loaders: { salesChannelLoader }, \n      storage: { channel } \n    } = ctx\n\n    const sc = await salesChannelLoader.load(channel.salesChannel);\n    \n    return sc.CurrencyCode ?? '';\n  },\n  priceValidUntil: (root) => {\n    if (isSearchItem(root)) {\n      return root.PriceValidUntil ?? ''\n    }\n\n    if (isOrderFormItem(root)) {\n      return root.priceValidUntil ?? ''\n    }\n\n    return null\n  },\n  itemCondition: () => 'https://schema.org/NewCondition',\n  availability: async (root) => {\n    if (isSearchItem(root)) {\n      return availability(inStock(root))\n    }\n\n    if (isOrderFormItem(root)) {\n      return availability(inStockOrderFormItem(root.availability))\n    }\n\n    return null\n  },\n  seller: (root) => {\n    if (isSearchItem(root)) {\n      return {\n        identifier: root.seller.sellerId ?? '',\n      }\n    }\n\n    if (isOrderFormItem(root)) {\n      return {\n        identifier: root.seller,\n      }\n    }\n\n    return null\n  },\n  price: (root) => {\n    if (isSearchItem(root)) {\n      return price(root)\n    }\n\n    if (isOrderFormItem(root)) {\n      return root.sellingPrice / 1e2\n    }\n\n    return null\n  },\n  sellingPrice: (root) => {\n    if (isSearchItem(root)) {\n      return sellingPrice(root)\n    }\n\n    if (isOrderFormItem(root)) {\n      return root.sellingPrice / 1e2\n    }\n\n    return null\n  },\n  listPrice: (root) => {\n    if (isSearchItem(root)) {\n      return root.ListPrice ?? 0\n    }\n\n    if (isOrderFormItem(root)) {\n      return root.listPrice / 1e2\n    }\n\n    return null\n  },\n  itemOffered: (root) => {\n    if (isSearchItem(root)) {\n      return root.product\n    }\n\n    if (isOrderFormItem(root)) {\n      return {\n        ...root.product,\n        attachmentsValues: root.attachments,\n      }\n    }\n\n    return null\n  },\n  quantity: (root) => {\n    if (isSearchItem(root)) {\n      return root.AvailableQuantity ?? 0\n    }\n\n    if (isOrderFormItem(root)) {\n      return root.quantity\n    }\n\n    return null\n  },\n}\n","import type { Product } from '../clients/search/types/ProductSearchResult'\n\nexport const canonicalFromProduct = ({ linkText }: Product) => `/${linkText}/p`\n","import { canonicalFromProduct } from '../utils/canonical'\nimport { enhanceCommercialOffer } from '../utils/enhanceCommercialOffer'\nimport { bestOfferFirst } from '../utils/productStock'\nimport { slugify } from '../utils/slugify'\nimport type { EnhancedCommercialOffer } from '../utils/enhanceCommercialOffer'\nimport type { Resolver } from '..'\nimport type { PromiseType } from '../../../typings'\nimport type { Query } from './query'\nimport {\n  attachmentToPropertyValue,\n  VALUE_REFERENCES,\n} from '../utils/propertyValue'\nimport type { Attachment } from '../clients/commerce/types/OrderForm'\n\ntype QueryProduct = PromiseType<ReturnType<typeof Query.product>>\n\ntype Root = QueryProduct & {\n  attachmentsValues?: Attachment[]\n}\n\nconst DEFAULT_IMAGE = {\n  imageText: 'image',\n  imageUrl:\n    'https://storecomponents.vtexassets.com/assets/faststore/images/image___117a6d3e229a96ad0e0d0876352566e2.svg',\n}\n\nconst getSlug = (link: string, id: string) => `${link}-${id}`\nconst getPath = (link: string, id: string) => `/${getSlug(link, id)}/p`\nconst nonEmptyArray = <T>(array: T[] | null | undefined) =>\n  Array.isArray(array) && array.length > 0 ? array : null\n\nexport const StoreProduct: Record<string, Resolver<Root>> & {\n  offers: Resolver<\n    Root,\n    any,\n    Array<EnhancedCommercialOffer<Root['sellers'][number], Root>>\n  >\n\n  isVariantOf: Resolver<Root, any, Root>\n} = {\n  productID: ({ itemId }) => itemId,\n  name: ({ isVariantOf, name }) => name ?? isVariantOf.productName,\n  slug: ({ isVariantOf: { linkText }, itemId }) => getSlug(linkText, itemId),\n  description: ({ isVariantOf: { description } }) => description,\n  seo: ({ isVariantOf }) => ({\n    title: isVariantOf.productName,\n    description: isVariantOf.description,\n    canonical: canonicalFromProduct(isVariantOf),\n  }),\n  brand: ({ isVariantOf: { brand } }) => ({ name: brand }),\n  breadcrumbList: ({\n    isVariantOf: { categories, productName, linkText },\n    itemId,\n  }) => {\n    return {\n      itemListElement: [\n        ...categories.reverse().map((categoryPath, index) => {\n          const splitted = categoryPath.split('/')\n          const name = splitted[splitted.length - 2]\n          const item = splitted.map(slugify).join('/')\n\n          return {\n            name,\n            item,\n            position: index + 1,\n          }\n        }),\n        {\n          name: productName,\n          item: getPath(linkText, itemId),\n          position: categories.length + 1,\n        },\n      ],\n      numberOfItems: categories.length,\n    }\n  },\n  image: ({ images }) =>\n    (nonEmptyArray(images) ?? [DEFAULT_IMAGE]).map(\n      ({ imageUrl, imageText }) => ({\n        alternateName: imageText ?? '',\n        url: imageUrl.replace('vteximg.com.br', 'vtexassets.com'),\n      })\n    ),\n  sku: ({ itemId }) => itemId,\n  gtin: ({ referenceId }) => referenceId[0]?.Value ?? '',\n  review: () => [],\n  aggregateRating: () => ({}),\n  offers: (root) =>\n    root.sellers\n      .map((seller) =>\n        enhanceCommercialOffer({\n          offer: seller.commertialOffer,\n          seller,\n          product: root,\n        })\n      )\n      .sort(bestOfferFirst),\n  isVariantOf: (root) => root,\n  additionalProperty: ({\n    // Search uses the name variations for specifications\n    variations: specifications = [],\n    attachmentsValues = [],\n  }) => {\n    const propertyValueSpecifications = specifications.flatMap(\n      ({ name, values }) =>\n        values.map((value) => ({\n          name,\n          value,\n          valueReference: VALUE_REFERENCES.specification,\n        }))\n    )\n\n    const propertyValueAttachments = attachmentsValues.map(\n      attachmentToPropertyValue\n    )\n\n    return [...propertyValueSpecifications, ...propertyValueAttachments]\n  },\n}\n","import type { CommertialOffer } from '../clients/search/types/ProductSearchResult'\n\nexport type EnhancedCommercialOffer<S, P> = CommertialOffer & {\n  seller: S\n  product: P\n}\n\nexport const enhanceCommercialOffer = <S, P>({\n  offer,\n  seller,\n  product,\n}: {\n  offer: CommertialOffer\n  seller: S\n  product: P\n}): EnhancedCommercialOffer<S, P> => ({\n  ...offer,\n  product,\n  seller,\n})\n","import { enhanceSku } from '../utils/enhanceSku'\nimport type { Resolver } from '..'\nimport type { PromiseType } from '../../../typings'\nimport type { StoreProduct } from './product'\nimport { VALUE_REFERENCES } from '../utils/propertyValue'\n\ntype Root = PromiseType<ReturnType<typeof StoreProduct.isVariantOf>>\n\nconst BLOCKED_SPECIFICATIONS = new Set(['allSpecifications'])\n\nexport const StoreProductGroup: Record<string, Resolver<Root>> = {\n  hasVariant: (root) =>\n    root.isVariantOf.items.map((item) => enhanceSku(item, root.isVariantOf)),\n  productGroupID: ({ isVariantOf }) => isVariantOf.productId,\n  name: ({ isVariantOf }) => isVariantOf.productName,\n  additionalProperty: ({ isVariantOf: { specificationGroups } }) =>\n    specificationGroups\n      // filter sku specifications so we dont mess sku with product specs\n      .filter(\n        (specificationGroup) =>\n          !BLOCKED_SPECIFICATIONS.has(specificationGroup.name)\n      )\n      // Transform specs back into product specs\n      .flatMap(({ specifications }) =>\n        specifications.flatMap(({ name, values }) =>\n          values.map((value) => ({\n            name,\n            value,\n            valueReference: VALUE_REFERENCES.specification,\n          }))\n        )\n      ),\n}\n","import ChannelMarshal from './channel'\nimport type { Context } from '..'\n\nexport const mutateChannelContext = (ctx: Context, channelString: string) => {\n  ctx.storage.channel = ChannelMarshal.parse(channelString)\n}\n\nexport const mutateLocaleContext = (ctx: Context, locale: string) => {\n  ctx.storage.locale = locale\n}\n","export const SORT_MAP = {\n  price_desc: 'price:desc',\n  price_asc: 'price:asc',\n  orders_desc: 'orders:desc',\n  name_desc: 'name:desc',\n  name_asc: 'name:asc',\n  release_desc: 'release:desc',\n  discount_desc: 'discount:desc',\n  score_desc: '',\n} as const\n","import { FACET_CROSS_SELLING_MAP } from \"./../utils/facets\"\nimport { BadRequestError, NotFoundError } from \"../../errors\"\nimport { mutateChannelContext, mutateLocaleContext } from \"../utils/contex\"\nimport { enhanceSku } from \"../utils/enhanceSku\"\nimport {\n  findChannel,\n  findCrossSelling,\n  findLocale,\n  findSkuId,\n  findSlug,\n  transformSelectedFacet,\n} from \"../utils/facets\"\nimport { SORT_MAP } from \"../utils/sort\"\nimport { StoreCollection } from \"./collection\"\nimport type {\n  QueryAllCollectionsArgs,\n  QueryAllProductsArgs,\n  QueryCollectionArgs,\n  QueryProductArgs,\n  QuerySearchArgs,\n} from \"../../../__generated__/schema\"\nimport type { CategoryTree } from \"../clients/commerce/types/CategoryTree\"\nimport type { Context } from \"../index\"\nimport { isValidSkuId, pickBestSku } from \"../utils/sku\"\n\nexport const Query = {\n  product: async (_: unknown, { locator }: QueryProductArgs, ctx: Context) => {\n    // Insert channel in context for later usage\n    const channel = findChannel(locator)\n    const locale = findLocale(locator)\n    const id = findSkuId(locator)\n    const slug = findSlug(locator)\n\n    if (channel) {\n      mutateChannelContext(ctx, channel)\n    }\n\n    if (locale) {\n      mutateLocaleContext(ctx, locale)\n    }\n\n    const {\n      loaders: { skuLoader },\n      clients: { commerce, search },\n    } = ctx\n\n    try {\n      const skuId = id ?? slug?.split('-').pop() ?? ''\n\n      if (!isValidSkuId(skuId)) {\n        throw new Error('Invalid SkuId')\n      }\n\n      const sku = await skuLoader.load(skuId)\n\n      return sku\n    } catch (err) {\n      if (slug == null) {\n        throw new BadRequestError('Missing slug or id')\n      }\n\n      const route = await commerce.catalog.portal.pagetype(`${slug}/p`)\n\n      if (route.pageType !== 'Product' || !route.id) {\n        throw new NotFoundError(`No product found for slug ${slug}`)\n      }\n\n      const {\n        products: [product],\n      } = await search.products({\n        page: 0,\n        count: 1,\n        query: `product:${route.id}`,\n      })\n\n      if (!product) {\n        throw new NotFoundError(`No product found for id ${route.id}`)\n      }\n\n      const sku = pickBestSku(product.items)\n\n      return enhanceSku(sku, product)\n    }\n  },\n  collection: (_: unknown, { slug }: QueryCollectionArgs, ctx: Context) => {\n    const {\n      loaders: { collectionLoader },\n    } = ctx\n\n    return collectionLoader.load(slug)\n  },\n  search: async (\n    _: unknown,\n    { first, after: maybeAfter, sort, term, selectedFacets }: QuerySearchArgs,\n    ctx: Context\n  ) => {\n    // Insert channel in context for later usage\n    const channel = findChannel(selectedFacets)\n    const locale = findLocale(selectedFacets)\n    const crossSelling = findCrossSelling(selectedFacets)\n\n    if (channel) {\n      mutateChannelContext(ctx, channel)\n    }\n\n    if (locale) {\n      mutateLocaleContext(ctx, locale)\n    }\n\n    let query = term\n\n    /**\n     * In case we are using crossSelling, we need to modify the search\n     * we will be performing on our search engine. The idea in here\n     * is to use the cross selling API for fetching the productIds our\n     * search will return for us.\n     * Doing this two request workflow makes it possible to have cross\n     * selling with Search features, like pagination, internationalization\n     * etc\n     */\n    if (crossSelling) {\n      const products = await ctx.clients.commerce.catalog.products.crossselling({\n        type: FACET_CROSS_SELLING_MAP[crossSelling.key],\n        productId: crossSelling.value,\n      })\n\n      query = `product:${\n        products.map((x) => x.productId).slice(0, first).join(\";\")\n      }`\n    }\n\n    const after = maybeAfter ? Number(maybeAfter) : 0\n    const searchArgs = {\n      page: Math.ceil(after / first),\n      count: first,\n      query,\n      sort: SORT_MAP[sort ?? 'score_desc'],\n      selectedFacets: selectedFacets?.flatMap(transformSelectedFacet) ?? [],\n    }\n\n    return searchArgs\n  },\n  allProducts: async (\n    _: unknown,\n    { first, after: maybeAfter }: QueryAllProductsArgs,\n    ctx: Context\n  ) => {\n    const {\n      clients: { search },\n    } = ctx\n\n    const after = maybeAfter ? Number(maybeAfter) : 0\n    const products = await search.products({\n      page: Math.ceil(after / first),\n      count: first,\n    })\n\n    const skus = products.products\n      .map((product) => product.items.map((sku) => enhanceSku(sku, product)))\n      .flat()\n      .filter((sku) => sku.sellers.length > 0)\n\n    return {\n      pageInfo: {\n        hasNextPage: products.pagination.after.length > 0,\n        hasPreviousPage: products.pagination.before.length > 0,\n        startCursor: '0',\n        endCursor: products.recordsFiltered.toString(),\n        totalCount: products.recordsFiltered,\n      },\n      // after + index is bigger than after+first itself because of the array flat() above\n      edges: skus.map((sku, index) => ({\n        node: sku,\n        cursor: (after + index).toString(),\n      })),\n    }\n  },\n  allCollections: async (\n    _: unknown,\n    { first, after: maybeAfter }: QueryAllCollectionsArgs,\n    ctx: Context\n  ) => {\n    const {\n      clients: { commerce },\n    } = ctx\n\n    const after = maybeAfter ? Number(maybeAfter) : 0\n\n    const [brands, tree] = await Promise.all([\n      commerce.catalog.brand.list(),\n      commerce.catalog.category.tree(),\n    ])\n\n    const categories: Array<CategoryTree & { level: number }> = []\n    const dfs = (node: CategoryTree, level: number) => {\n      categories.push({ ...node, level })\n\n      for (const child of node.children) {\n        dfs(child, level + 1)\n      }\n    }\n\n    for (const node of tree) {\n      dfs(node, 0)\n    }\n\n    const collections = [\n      ...brands\n        .filter((brand) => brand.isActive)\n        .map((x) => ({ ...x, type: 'brand' })),\n      ...categories,\n    ]\n\n    const validCollections = collections\n      // Nullable slugs may cause one route to override the other\n      .filter((node) => Boolean(StoreCollection.slug(node, null, ctx, null)))\n\n    return {\n      pageInfo: {\n        hasNextPage: validCollections.length - after > first,\n        hasPreviousPage: after > 0,\n        startCursor: '0',\n        endCursor: (\n          Math.min(first, validCollections.length - after) - 1\n        ).toString(),\n        totalCount: validCollections.length,\n      },\n      edges: validCollections\n        .slice(after, after + first)\n        .map((node, index) => ({\n          node,\n          cursor: (after + index).toString(),\n        })),\n    }\n  },\n}\n","import { min } from './orderStatistics'\nimport { bestOfferFirst } from './productStock'\nimport type { Item } from '../clients/search/types/ProductSearchResult'\n\n/**\n * This function implements Portal heuristics for returning the best sku for a product.\n *\n * The best sku is the one with the best (cheapest available) offer\n * */\nexport const pickBestSku = (skus: Item[]) => {\n  const offersBySku = skus.flatMap((sku) =>\n    sku.sellers.map((seller) => ({\n      offer: seller.commertialOffer,\n      sku,\n    }))\n  )\n\n  const best = min(offersBySku, ({ offer: o1 }, { offer: o2 }) =>\n    bestOfferFirst(o1, o2)\n  )\n\n  return best.sku\n}\n\nexport const isValidSkuId = (skuId: string) =>\n  skuId !== '' && !Number.isNaN(Number(skuId))\n","import { getClients } from './clients'\nimport type { SearchArgs } from './clients/search'\nimport { getLoaders } from './loaders'\nimport { StoreAggregateOffer } from './resolvers/aggregateOffer'\nimport { StoreAggregateRating } from './resolvers/aggregateRating'\nimport { StoreCollection } from './resolvers/collection'\nimport {\n  StoreFacet,\n  StoreFacetBoolean,\n  StoreFacetRange,\n} from './resolvers/facet'\nimport { StoreFacetValueBoolean } from './resolvers/faceValue'\nimport { Mutation } from './resolvers/mutation'\nimport { ObjectOrString } from './resolvers/objectOrString'\nimport { StoreOffer } from './resolvers/offer'\nimport { StoreProduct } from './resolvers/product'\nimport { StoreProductGroup } from './resolvers/productGroup'\nimport { StorePropertyValue } from './resolvers/propertyValue'\nimport { Query } from './resolvers/query'\nimport { StoreReview } from './resolvers/review'\nimport { StoreSearchResult } from './resolvers/searchResult'\nimport { StoreSeo } from './resolvers/seo'\nimport ChannelMarshal from './utils/channel'\nimport type { Loaders } from './loaders'\nimport type { Clients } from './clients'\nimport type { Channel } from './utils/channel'\n\nexport interface Options {\n  platform: 'vtex'\n  account: string\n  environment: 'vtexcommercestable' | 'vtexcommercebeta'\n  // Default sales channel to use for fetching products\n  channel: string\n  locale: string\n  hideUnavailableItems: boolean\n  flags?: FeatureFlags\n}\n\ninterface FeatureFlags {\n  enableOrderFormSync?: boolean\n}\n\nexport interface Context {\n  clients: Clients\n  loaders: Loaders\n  /**\n   * @description Storage updated at each request.\n   *\n   * Use this datastructure to store and share small values in the context.\n   * Use it with caution since dependecy injection leads to a more complex code\n   * */\n  storage: {\n    channel: Required<Channel>\n    locale: string\n    flags: FeatureFlags\n    searchArgs?: Omit<SearchArgs, 'type'>\n  }\n  headers: Record<string, string>\n}\n\nexport type Resolver<R = unknown, A = unknown, Return = any> = (\n  root: R,\n  args: A,\n  ctx: Context,\n  info: any\n) => Return\n\nconst Resolvers = {\n  StoreCollection,\n  StoreAggregateOffer,\n  StoreProduct,\n  StoreSeo,\n  StoreFacet,\n  StoreFacetBoolean,\n  StoreFacetRange,\n  StoreFacetValueBoolean,\n  StoreOffer,\n  StoreAggregateRating,\n  StoreReview,\n  StoreProductGroup,\n  StoreSearchResult,\n  StorePropertyValue,\n  ObjectOrString,\n  Query,\n  Mutation,\n}\n\nexport const getContextFactory =\n  (options: Options) =>\n  (ctx: any): Context => {\n    ctx.storage = {\n      channel: ChannelMarshal.parse(options.channel),\n      flags: options.flags ?? {},\n      locale: options.locale,\n    }\n    ctx.clients = getClients(options, ctx)\n    ctx.loaders = getLoaders(options, ctx)\n\n    return ctx\n  }\n\nexport const getResolvers = (_: Options) => Resolvers\n","import type { Resolver } from '..'\n\ntype Root = { title?: string; description?: string; canonical?: string }\n\nexport const StoreSeo: Record<string, Resolver<Root>> = {\n  title: ({ title }) => title ?? '',\n  description: ({ description }) => description ?? '',\n  canonical: ({ canonical }) => canonical ?? '',\n  titleTemplate: () => '',\n}\n","import type { Resolver } from '..'\nimport type { FacetValueBoolean } from '../clients/search/types/FacetSearchResult'\n\nexport const StoreFacetValueBoolean: Record<\n  string,\n  Resolver<FacetValueBoolean>\n> = {\n  value: ({ value }) => value,\n  label: ({ name }) => name || 'unknown',\n  selected: ({ selected }) => selected,\n  quantity: ({ quantity }) => quantity,\n}\n","import type { Resolver } from '..'\n\n// TODO: Add a review system integration\nexport const StoreAggregateRating: Record<string, Resolver> = {\n  ratingValue: () => 5,\n  reviewCount: () => 0,\n}\n","import type { Resolver } from '..'\n\nexport const StoreReview: Record<string, Resolver> = {\n  reviewRating: () => ({\n    ratingValue: 5,\n    bestRating: 5,\n  }),\n  author: () => ({\n    name: '',\n  }),\n}\n","import { enhanceSku } from '../utils/enhanceSku'\nimport type { Resolver } from '..'\nimport type { SearchArgs } from '../clients/search'\nimport type { Facet } from '../clients/search/types/FacetSearchResult'\n\ntype Root = Omit<SearchArgs, 'type'>\n\nconst isRootFacet = (facet: Facet) => facet.key === 'category-1'\n\nexport const StoreSearchResult: Record<string, Resolver<Root>> = {\n  suggestions: async (searchArgs, _, ctx) => {\n    const {\n      clients: { search },\n    } = ctx\n\n    // If there's no search query, suggest the most popular searches.\n    if (!searchArgs.query) {\n      const topSearches = await search.topSearches()\n\n      return {\n        terms: topSearches.searches.map((item) => ({\n          value: item.term,\n          count: item.count,\n        })),\n        products: [],\n      }\n    }\n\n    const terms = await search.suggestedTerms(searchArgs)\n    const products = await search.products(searchArgs)\n\n    const skus = products.products\n      .map((product) => {\n        const [maybeSku] = product.items\n\n        return maybeSku && enhanceSku(maybeSku, product)\n      })\n      .filter((sku) => !!sku)\n\n    const { searches } = terms\n\n    return {\n      terms: searches.map((item) => ({ value: item.term, count: item.count })),\n      products: skus,\n    }\n  },\n  products: async (searchArgs, _, ctx) => {\n    const {\n      clients: { search, sp },\n    } = ctx\n\n    const products = await search.products(searchArgs)\n\n    // Raise event on search's analytics API when performing\n    // a full text search.\n    if (searchArgs.query) {\n      sp.sendEvent({\n        type: 'search.query',\n        text: searchArgs.query,\n        misspelled: products.correction.misspelled,\n        match: products.recordsFiltered,\n        operator: products.operator,\n      }).catch(console.error)\n    }\n\n    const skus = products.products\n      .map((product) => {\n        const [maybeSku] = product.items\n\n        return maybeSku && enhanceSku(maybeSku, product)\n      })\n      .filter((sku) => !!sku)\n\n    return {\n      pageInfo: {\n        hasNextPage: products.pagination.after.length > 0,\n        hasPreviousPage: products.pagination.before.length > 0,\n        startCursor: '0',\n        endCursor: products.recordsFiltered.toString(),\n        totalCount: products.recordsFiltered,\n      },\n      edges: skus.map((sku, index) => ({\n        node: sku,\n        cursor: index.toString(),\n      })),\n    }\n  },\n  facets: async (searchArgs, _, ctx) => {\n    const {\n      clients: { search: is },\n    } = ctx\n\n    ctx.storage.searchArgs = searchArgs\n\n    const { facets = [] } = await is.facets(searchArgs)\n\n    const isCollectionPage = !searchArgs.query\n\n    const filteredFacets = facets\n      // Remove root facet on category pages\n      .filter((facet) => !isCollectionPage || !isRootFacet(facet))\n\n    return filteredFacets\n  },\n}\n","import type { Resolver } from '..'\nimport type { IStorePropertyValue } from '../../../__generated__/schema'\nimport { getPropertyId } from '../utils/propertyValue'\n\ntype Root = IStorePropertyValue\n\nexport const StorePropertyValue: Record<string, Resolver<Root>> = {\n  propertyID: (root) => getPropertyId(root),\n  name: ({ name }) => name,\n  value: ({ value }) => value,\n  valueReference: ({ valueReference }) => valueReference,\n}\n","import { print } from 'graphql'\n\nimport AggregateOffer from './aggregateOffer.graphql'\nimport AggregateRating from './aggregateRating.graphql'\nimport Author from './author.graphql'\nimport Brand from './brand.graphql'\nimport Breadcrumb from './breadcrumb.graphql'\nimport Collection from './collection.graphql'\nimport Facet from './facet.graphql'\nimport Image from './image.graphql'\nimport Mutation from './mutation.graphql'\nimport Offer from './offer.graphql'\nimport Order from './order.graphql'\nimport Organization from './organization.graphql'\nimport PageInfo from './pageInfo.graphql'\nimport Product from './product.graphql'\nimport ProductGroup from './productGroup.graphql'\nimport Query from './query.graphql'\nimport Review from './review.graphql'\nimport Seo from './seo.graphql'\nimport Cart from './cart.graphql'\nimport Status from './status.graphql'\nimport PropertyValue from './propertyValue.graphql'\nimport Person from './person.graphql'\nimport ObjectOrString from './objectOrString.graphql'\nimport Session from './session.graphql'\n\nexport const typeDefs = [\n  Query,\n  Mutation,\n  Brand,\n  Breadcrumb,\n  Collection,\n  Facet,\n  Image,\n  PageInfo,\n  Product,\n  Seo,\n  Offer,\n  AggregateRating,\n  Review,\n  Author,\n  ProductGroup,\n  Organization,\n  AggregateOffer,\n  Order,\n  Cart,\n  Status,\n  PropertyValue,\n  Person,\n  ObjectOrString,\n  Session,\n]\n  .map(print)\n  .join('\\n')\n","import { makeExecutableSchema } from '@graphql-tools/schema'\n\nimport {\n  getContextFactory as getContextFactoryVTEX,\n  getResolvers as getResolversVTEX,\n} from './platforms/vtex'\nimport { typeDefs } from './typeDefs'\nimport type { Options as OptionsVTEX } from './platforms/vtex'\n\nexport * from './__generated__/schema'\nexport * from './platforms/errors'\n\nexport type Options = OptionsVTEX\n\nconst platforms = {\n  vtex: {\n    getResolvers: getResolversVTEX,\n    getContextFactory: getContextFactoryVTEX,\n  },\n}\n\nexport const getTypeDefs = () => typeDefs\n\nexport const getResolvers = (options: Options) =>\n  platforms[options.platform].getResolvers(options)\n\nexport const getContextFactory = (options: Options) =>\n  platforms[options.platform].getContextFactory(options)\n\nexport const getSchema = async (options: Options) =>\n  makeExecutableSchema({\n    resolvers: getResolvers(options),\n    typeDefs,\n  })\n","import { VtexCommerce } from './commerce'\nimport { IntelligentSearch } from './search'\nimport { SP } from './sp'\nimport type { Context, Options } from '..'\n\nexport type Clients = ReturnType<typeof getClients>\n\nexport const getClients = (options: Options, ctx: Context) => {\n  const search = IntelligentSearch(options, ctx)\n  const commerce = VtexCommerce(options, ctx)\n  const sp = SP(options, ctx)\n\n  return {\n    search,\n    commerce,\n    sp,\n  }\n}\n","import { getSalesChannelLoader } from './salesChannel';\nimport { getSimulationLoader } from './simulation'\nimport { getSkuLoader } from './sku'\nimport { getCollectionLoader } from './collection'\nimport type { Context, Options } from '..'\n\nexport type Loaders = ReturnType<typeof getLoaders>\n\nexport const getLoaders = (options: Options, { clients }: Context) => {\n  const skuLoader = getSkuLoader(options, clients)\n  const simulationLoader = getSimulationLoader(options, clients)\n  const collectionLoader = getCollectionLoader(options, clients)\n  const salesChannelLoader = getSalesChannelLoader(options, clients)\n\n  return {\n    skuLoader,\n    simulationLoader,\n    collectionLoader,\n    salesChannelLoader\n  }\n}\n","import DataLoader from 'dataloader'\n\nimport { enhanceSku } from '../utils/enhanceSku'\nimport { NotFoundError } from '../../errors'\nimport type { EnhancedSku } from '../utils/enhanceSku'\nimport type { Options } from '..'\nimport type { Clients } from '../clients'\n\nexport const getSkuLoader = (_: Options, clients: Clients) => {\n  const loader = async (skuIds: readonly string[]) => {\n    const { products } = await clients.search.products({\n      query: `sku:${skuIds.join(';')}`,\n      page: 0,\n      count: skuIds.length,\n    })\n\n    const skuBySkuId = products.reduce((acc, product) => {\n      for (const sku of product.items) {\n        acc[sku.itemId] = enhanceSku(sku, product)\n      }\n\n      return acc\n    }, {} as Record<string, EnhancedSku>)\n\n    const skus = skuIds.map((skuId) => skuBySkuId[skuId])\n    const missingSkus = skuIds.filter((skuId) => !skuBySkuId[skuId])\n\n    if (missingSkus.length > 0) {\n      throw new NotFoundError(\n        `Search API did not found the following skus: ${missingSkus.join(',')}`\n      )\n    }\n\n    return skus\n  }\n\n  return new DataLoader<string, EnhancedSku>(loader, {\n    maxBatchSize: 99, // Max allowed batch size of Search API\n  })\n}\n","import DataLoader from 'dataloader'\nimport pLimit from 'p-limit'\n\nimport type {\n  PayloadItem,\n  Simulation,\n} from '../clients/commerce/types/Simulation'\nimport type { Options } from '..'\nimport type { Clients } from '../clients'\n\n// Limits concurrent requests to the API per request cycle\nconst CONCURRENT_REQUESTS_MAX = 1\n\nexport const getSimulationLoader = (_: Options, clients: Clients) => {\n  const limit = pLimit(CONCURRENT_REQUESTS_MAX)\n\n  const loader = async (allItems: readonly PayloadItem[][]) => {\n    const items = [...allItems.flat()]\n    const simulation = await clients.commerce.checkout.simulation({\n      items,\n    })\n\n    // Sort and filter simulation since Checkout API may return\n    // items that we didn't ask for\n    const simulated = simulation.items.reduce((acc, item) => {\n      const index = item.requestIndex\n\n      if (typeof index === 'number' && index < acc.length) {\n        acc[index] = item\n      }\n\n      return acc\n    }, Array(items.length).fill(null) as Simulation['items'])\n\n    const itemsIndices = allItems.reduce(\n      (acc, curr) => [...acc, curr.length + acc[acc.length - 1]],\n      [0]\n    )\n\n    return allItems.map((__, index) => ({\n      ...simulation,\n      items: simulated\n        .slice(itemsIndices[index], itemsIndices[index + 1])\n        .filter((item) => Boolean(item)),\n    }))\n  }\n\n  const limited = async (allItems: readonly PayloadItem[][]) =>\n    limit(loader, allItems)\n\n  return new DataLoader<PayloadItem[], Simulation>(limited, {\n    maxBatchSize: 50,\n  })\n}\n","import DataLoader from \"dataloader\";\n\nimport { Options } from \"..\";\nimport { Clients } from \"../clients\";\n\nimport type { SalesChannel } from \"./../clients/commerce/types/SalesChannel\";\n\nexport const getSalesChannelLoader = (_: Options, clients: Clients) => {\n  const loader = async (channels: readonly string[]) =>\n    Promise.all(\n      channels.map((sc) => clients.commerce.catalog.salesChannel(sc)),\n    );\n\n  return new DataLoader<string, SalesChannel>(loader);\n};\n"],"names":["fetchAPI","async","info","init","response","fetch","ok","status","json","undefined","console","error","text","Error","BASE_INIT","method","headers","CHANNEL_KEYS","Set","IntelligentSearch","account","environment","hideUnavailableItems","ctx","base","search","query","page","count","sort","selectedFacets","type","fuzzy","params","URLSearchParams","toString","locale","storage","append","pathname","facets","withDefaltFacets","filter","key","has","policyFacet","find","salesChannel","channel","value","getPolicyFacet","regionFacet","regionId","getRegionFacet","push","addDefaultFacets","map","join","args","products","suggestedTerms","_args$query","topSearches","randomUUID","Math","random","toFixed","createId","expiresSecond","payload","createdAt","Date","now","past","user","anonymous","session","enhanceSku","item","product","isVariantOf","FastStoreError","constructor","extensions","message","name","BadRequestError","NotFoundError","collectionPageTypes","isCollectionPageType","x","pageType","toLowerCase","inStock","offer","AvailableQuantity","price","spotPrice","availability","available","bestOfferFirst","a","b","StoreAggregateOffer","highPrice","offers","availableOffers","highOffer","length","lowPrice","lowOffer","offerCount","priceCurrency","_","__","loaders","salesChannelLoader","load","CurrencyCode","from","slugify","str","replace","slugifySpecialCharacters","newStr","slice","i","RegExp","charAt","removeDiacritics","isBrand","slugifyRoot","root","URL","url","StoreCollection","id","slug","seo","title","description","metaTagDescription","Title","MetaTagDescription","level","meta","split","segment","index","breadcrumbList","collectionLoader","segments","Boolean","slugs","collections","Promise","all","s","itemListElement","collection","position","numberOfItems","ChannelMarshal","channelString","parsedChannel","JSON","parse","stringify","FACET_CROSS_SELLING_MAP","buy","view","similars","viewAndBought","accessories","suggestions","transformSelectedFacet","channelFacets","parseRange","range","splitted","Number","isNaN","findLocale","_facets$find3","findChannel","facet","_facets$find4","min","array","cmp","best","curr","StoreFacetRange","label","values","searchArgs","selectedRange","_searchArgs$selectedF2","_searchArgs$selectedF3","globalMin","selected","absolute","max","_searchArgs$selectedF5","_searchArgs$selectedF6","to","globalMax","md5","crypto","createHash","update","digest","attachmentToPropertyValue","attachment","content","valueReference","getPropertyId","isAttachment","getId","itemOffered","sku","seller","identifier","additionalProperty","_item$itemOffered$add","orderFormItemToOffer","listPrice","sellingPrice","quantity","image","attachments","offerToOrderItemInput","_offer$itemOffered$ad2","groupById","reduce","acc","set","get","Map","orderFormToCart","form","skuLoader","order","orderNumber","orderFormId","acceptedOffer","items","messages","toUpperCase","getOrderFormEtag","setOrderFormEtag","commerce","checkout","setCustomData","appId","err","Mutation","validateCart","cart","enableOrderFormSync","flags","clients","orderForm","faststoreData","customData","_form$customData","customApps","app","oldEtag","fields","_faststoreData$fields","cartEtag","isOrderFormStale","newOrderForm","browserItemsById","originItemsById","browserItems","Array","originItems","itemsToAdd","itemsToUpdate","maybeOriginItem","changes","updatedOrderForm","updateOrderFormItems","orderItems","then","storeOrder","pick","orderFormItems","storeOrderItems","isSameOrder","orderItemsAreSync","deepEquals","equals","validateSession","oldSession","postalCode","String","country","regionData","sessionData","region","resolve","catch","profile","namespaces","store","newSession","currency","code","currencyCode","symbol","currencySymbol","countryCode","_store$channel","_regionData$","person","_profile$id","email","_profile$email","givenName","firstName","_profile$firstName","familyName","lastName","_profile$lastName","ObjectOrString","GraphQLScalarType","parseValue","getValueAsObjectOrString","serialize","parseLiteral","ast","kind","Kind","STRING","e","isSearchItem","isOrderFormItem","StoreOffer","priceValidUntil","PriceValidUntil","itemCondition","sellerId","Price","ListPrice","attachmentsValues","canonicalFromProduct","linkText","DEFAULT_IMAGE","imageText","imageUrl","getSlug","link","StoreProduct","productID","itemId","productName","canonical","brand","categories","reverse","categoryPath","images","isArray","alternateName","gtin","referenceId","_referenceId$","Value","review","aggregateRating","sellers","enhanceCommercialOffer","commertialOffer","variations","specifications","flatMap","BLOCKED_SPECIFICATIONS","mutateChannelContext","mutateLocaleContext","SORT_MAP","price_desc","price_asc","orders_desc","name_desc","name_asc","release_desc","discount_desc","score_desc","Query","locator","_facets$find2","_facets$find","findSlug","skuId","pop","isValidSkuId","route","catalog","portal","pagetype","skus","offersBySku","o1","o2","pickBestSku","first","after","maybeAfter","term","crossSelling","filtered","isCrossSelling","findCrossSelling","crossselling","productId","ceil","allProducts","flat","pageInfo","hasNextPage","pagination","hasPreviousPage","before","startCursor","endCursor","recordsFiltered","totalCount","edges","node","cursor","allCollections","brands","tree","list","category","dfs","child","children","validCollections","isActive","Resolvers","StoreSeo","titleTemplate","StoreFacet","__resolveType","StoreFacetBoolean","localeCompare","StoreFacetValueBoolean","StoreAggregateRating","ratingValue","reviewCount","StoreReview","reviewRating","bestRating","author","StoreProductGroup","hasVariant","productGroupID","specificationGroups","specificationGroup","StoreSearchResult","terms","searches","maybeSku","sp","sendEvent","misspelled","correction","match","operator","is","isCollectionPage","isRootFacet","StorePropertyValue","propertyID","typeDefs","Brand","Breadcrumb","Collection","Facet","Image","PageInfo","Product","Seo","Offer","AggregateRating","Review","Author","ProductGroup","Organization","AggregateOffer","Order","Cart","Status","PropertyValue","Person","Session","print","platforms","vtex","getResolvers","getContextFactory","options","sc","depth","groupByProduct","simulation","body","refreshOutdatedData","allowOutdatedData","cookie","VtexCommerce","agent","SP","getClients","DataLoader","skuIds","skuBySkuId","missingSkus","maxBatchSize","getSkuLoader","simulationLoader","limit","pLimit","loader","allItems","simulated","requestIndex","fill","itemsIndices","getSimulationLoader","batch","getCollectionLoader","channels","getSalesChannelLoader","getLoaders","platform","makeExecutableSchema","resolvers"],"mappings":"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"}